{'type': 'FunctionDefinition', 'name': 'IERC1155Receiver.onERC1155Received', 'start_line': 5, 'end_line': 11, 'offset_start': 117, 'offset_end': 295, 'content': 'function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);', 'contract_name': 'IERC1155Receiver', 'contract_code': '{\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1155Receiver.onERC1155BatchReceived', 'start_line': 12, 'end_line': 18, 'offset_start': 301, 'offset_end': 508, 'content': 'function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);', 'contract_name': 'IERC1155Receiver', 'contract_code': '{\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouter.tor', 'start_line': 31, 'end_line': 31, 'offset_start': 1087, 'offset_end': 1157, 'content': 'constructor(RouterParameters memory params) RouterImmutables(params) {}', 'contract_name': 'UniversalRouter', 'contract_code': '{\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\n        _;\n    }\n    constructor(RouterParameters memory params) RouterImmutables(params) {}\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)\n        external\n        payable\n        checkDeadline(deadline)\n    {\n        execute(commands, inputs);\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) public payable override isNotLocked {\n        bool success;\n        bytes memory output;\n        uint256 numCommands = commands.length;\n        if (inputs.length != numCommands) revert LengthMismatch();\n        for (uint256 commandIndex = 0; commandIndex < numCommands;) {\n            bytes1 command = commands[commandIndex];\n            bytes calldata input = inputs[commandIndex];\n            (success, output) = dispatch(command, input);\n            if (!success && successRequired(command)) {\n                revert ExecutionFailed({commandIndex: commandIndex, message: output});\n            }\n            unchecked {\n                commandIndex++;\n            }\n        }\n    }\n    function successRequired(bytes1 command) internal pure returns (bool) {\n        return command & Commands.FLAG_ALLOW_REVERT == 0;\n    }\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouter.execute', 'start_line': 32, 'end_line': 38, 'offset_start': 1163, 'offset_end': 1358, 'content': 'function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)\n        external\n        payable\n        checkDeadline(deadline)\n    {\n        execute(commands, inputs);\n    }', 'contract_name': 'UniversalRouter', 'contract_code': '{\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\n        _;\n    }\n    constructor(RouterParameters memory params) RouterImmutables(params) {}\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)\n        external\n        payable\n        checkDeadline(deadline)\n    {\n        execute(commands, inputs);\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) public payable override isNotLocked {\n        bool success;\n        bytes memory output;\n        uint256 numCommands = commands.length;\n        if (inputs.length != numCommands) revert LengthMismatch();\n        for (uint256 commandIndex = 0; commandIndex < numCommands;) {\n            bytes1 command = commands[commandIndex];\n            bytes calldata input = inputs[commandIndex];\n            (success, output) = dispatch(command, input);\n            if (!success && successRequired(command)) {\n                revert ExecutionFailed({commandIndex: commandIndex, message: output});\n            }\n            unchecked {\n                commandIndex++;\n            }\n        }\n    }\n    function successRequired(bytes1 command) internal pure returns (bool) {\n        return command & Commands.FLAG_ALLOW_REVERT == 0;\n    }\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouter.execute', 'start_line': 39, 'end_line': 55, 'offset_start': 1364, 'offset_end': 2113, 'content': 'function execute(bytes calldata commands, bytes[] calldata inputs) public payable override isNotLocked {\n        bool success;\n        bytes memory output;\n        uint256 numCommands = commands.length;\n        if (inputs.length != numCommands) revert LengthMismatch();\n        for (uint256 commandIndex = 0; commandIndex < numCommands;) {\n            bytes1 command = commands[commandIndex];\n            bytes calldata input = inputs[commandIndex];\n            (success, output) = dispatch(command, input);\n            if (!success && successRequired(command)) {\n                revert ExecutionFailed({commandIndex: commandIndex, message: output});\n            }\n            unchecked {\n                commandIndex++;\n            }\n        }\n    }', 'contract_name': 'UniversalRouter', 'contract_code': '{\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\n        _;\n    }\n    constructor(RouterParameters memory params) RouterImmutables(params) {}\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)\n        external\n        payable\n        checkDeadline(deadline)\n    {\n        execute(commands, inputs);\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) public payable override isNotLocked {\n        bool success;\n        bytes memory output;\n        uint256 numCommands = commands.length;\n        if (inputs.length != numCommands) revert LengthMismatch();\n        for (uint256 commandIndex = 0; commandIndex < numCommands;) {\n            bytes1 command = commands[commandIndex];\n            bytes calldata input = inputs[commandIndex];\n            (success, output) = dispatch(command, input);\n            if (!success && successRequired(command)) {\n                revert ExecutionFailed({commandIndex: commandIndex, message: output});\n            }\n            unchecked {\n                commandIndex++;\n            }\n        }\n    }\n    function successRequired(bytes1 command) internal pure returns (bool) {\n        return command & Commands.FLAG_ALLOW_REVERT == 0;\n    }\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouter.successRequired', 'start_line': 56, 'end_line': 58, 'offset_start': 2119, 'offset_end': 2253, 'content': 'function successRequired(bytes1 command) internal pure returns (bool) {\n        return command & Commands.FLAG_ALLOW_REVERT == 0;\n    }', 'contract_name': 'UniversalRouter', 'contract_code': '{\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\n        _;\n    }\n    constructor(RouterParameters memory params) RouterImmutables(params) {}\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)\n        external\n        payable\n        checkDeadline(deadline)\n    {\n        execute(commands, inputs);\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) public payable override isNotLocked {\n        bool success;\n        bytes memory output;\n        uint256 numCommands = commands.length;\n        if (inputs.length != numCommands) revert LengthMismatch();\n        for (uint256 commandIndex = 0; commandIndex < numCommands;) {\n            bytes1 command = commands[commandIndex];\n            bytes calldata input = inputs[commandIndex];\n            (success, output) = dispatch(command, input);\n            if (!success && successRequired(command)) {\n                revert ExecutionFailed({commandIndex: commandIndex, message: output});\n            }\n            unchecked {\n                commandIndex++;\n            }\n        }\n    }\n    function successRequired(bytes1 command) internal pure returns (bool) {\n        return command & Commands.FLAG_ALLOW_REVERT == 0;\n    }\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouter.', 'start_line': 59, 'end_line': 59, 'offset_start': 2259, 'offset_end': 2287, 'content': 'receive() external payable {}', 'contract_name': 'UniversalRouter', 'contract_code': '{\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\n        _;\n    }\n    constructor(RouterParameters memory params) RouterImmutables(params) {}\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)\n        external\n        payable\n        checkDeadline(deadline)\n    {\n        execute(commands, inputs);\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) public payable override isNotLocked {\n        bool success;\n        bytes memory output;\n        uint256 numCommands = commands.length;\n        if (inputs.length != numCommands) revert LengthMismatch();\n        for (uint256 commandIndex = 0; commandIndex < numCommands;) {\n            bytes1 command = commands[commandIndex];\n            bytes calldata input = inputs[commandIndex];\n            (success, output) = dispatch(command, input);\n            if (!success && successRequired(command)) {\n                revert ExecutionFailed({commandIndex: commandIndex, message: output});\n            }\n            unchecked {\n                commandIndex++;\n            }\n        }\n    }\n    function successRequired(bytes1 command) internal pure returns (bool) {\n        return command & Commands.FLAG_ALLOW_REVERT == 0;\n    }\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'RouterImmutables.tor', 'start_line': 112, 'end_line': 133, 'offset_start': 4109, 'offset_end': 5125, 'content': 'constructor(RouterParameters memory params) {\n        PERMIT2 = IAllowanceTransfer(params.permit2);\n        WETH9 = IWETH9(params.weth9);\n        SEAPORT_V1_5 = params.seaportV1_5;\n        SEAPORT_V1_4 = params.seaportV1_4;\n        OPENSEA_CONDUIT = params.openseaConduit;\n        NFTX_ZAP = params.nftxZap;\n        X2Y2 = params.x2y2;\n        FOUNDATION = params.foundation;\n        SUDOSWAP = params.sudoswap;\n        ELEMENT_MARKET = params.elementMarket;\n        NFT20_ZAP = params.nft20Zap;\n        CRYPTOPUNKS = params.cryptopunks;\n        LOOKS_RARE_V2 = params.looksRareV2;\n        LOOKS_RARE_TOKEN = ERC20(params.looksRareToken);\n        LOOKS_RARE_REWARDS_DISTRIBUTOR = params.looksRareRewardsDistributor;\n        ROUTER_REWARDS_DISTRIBUTOR = params.routerRewardsDistributor;\n        UNISWAP_V2_FACTORY = params.v2Factory;\n        UNISWAP_V2_PAIR_INIT_CODE_HASH = params.pairInitCodeHash;\n        UNISWAP_V3_FACTORY = params.v3Factory;\n        UNISWAP_V3_POOL_INIT_CODE_HASH = params.poolInitCodeHash;\n    }', 'contract_name': 'RouterImmutables', 'contract_code': '{\n    IWETH9 internal immutable WETH9;\n    IAllowanceTransfer internal immutable PERMIT2;\n    address internal immutable SEAPORT_V1_5;\n    address internal immutable SEAPORT_V1_4;\n    address internal immutable OPENSEA_CONDUIT;\n    address internal immutable NFTX_ZAP;\n    address internal immutable X2Y2;\n    address internal immutable FOUNDATION;\n    address internal immutable SUDOSWAP;\n    address internal immutable ELEMENT_MARKET;\n    address internal immutable NFT20_ZAP;\n    address internal immutable CRYPTOPUNKS;\n    address internal immutable LOOKS_RARE_V2;\n    ERC20 internal immutable LOOKS_RARE_TOKEN;\n    address internal immutable LOOKS_RARE_REWARDS_DISTRIBUTOR;\n    address internal immutable ROUTER_REWARDS_DISTRIBUTOR;\n    address internal immutable UNISWAP_V2_FACTORY;\n    bytes32 internal immutable UNISWAP_V2_PAIR_INIT_CODE_HASH;\n    address internal immutable UNISWAP_V3_FACTORY;\n    bytes32 internal immutable UNISWAP_V3_POOL_INIT_CODE_HASH;\n    enum Spenders {\n        OSConduit,\n        Sudoswap\n    }\n    constructor(RouterParameters memory params) {\n        PERMIT2 = IAllowanceTransfer(params.permit2);\n        WETH9 = IWETH9(params.weth9);\n        SEAPORT_V1_5 = params.seaportV1_5;\n        SEAPORT_V1_4 = params.seaportV1_4;\n        OPENSEA_CONDUIT = params.openseaConduit;\n        NFTX_ZAP = params.nftxZap;\n        X2Y2 = params.x2y2;\n        FOUNDATION = params.foundation;\n        SUDOSWAP = params.sudoswap;\n        ELEMENT_MARKET = params.elementMarket;\n        NFT20_ZAP = params.nft20Zap;\n        CRYPTOPUNKS = params.cryptopunks;\n        LOOKS_RARE_V2 = params.looksRareV2;\n        LOOKS_RARE_TOKEN = ERC20(params.looksRareToken);\n        LOOKS_RARE_REWARDS_DISTRIBUTOR = params.looksRareRewardsDistributor;\n        ROUTER_REWARDS_DISTRIBUTOR = params.routerRewardsDistributor;\n        UNISWAP_V2_FACTORY = params.v2Factory;\n        UNISWAP_V2_PAIR_INIT_CODE_HASH = params.pairInitCodeHash;\n        UNISWAP_V3_FACTORY = params.v3Factory;\n        UNISWAP_V3_POOL_INIT_CODE_HASH = params.poolInitCodeHash;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155.uri', 'start_line': 155, 'end_line': 155, 'offset_start': 5810, 'offset_end': 5878, 'content': 'function uri(uint256 id) public view virtual returns (string memory);', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155.setApprovalForAll', 'start_line': 156, 'end_line': 159, 'offset_start': 5884, 'offset_end': 6085, 'content': 'function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155.safeTransferFrom', 'start_line': 160, 'end_line': 178, 'offset_start': 6091, 'offset_end': 6786, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155.safeBatchTransferFrom', 'start_line': 179, 'end_line': 207, 'offset_start': 6792, 'offset_end': 7822, 'content': 'function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155.balanceOfBatch', 'start_line': 208, 'end_line': 221, 'offset_start': 7828, 'offset_end': 8277, 'content': 'function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155.supportsInterface', 'start_line': 222, 'end_line': 227, 'offset_start': 8283, 'offset_end': 8510, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155._mint', 'start_line': 228, 'end_line': 243, 'offset_start': 8516, 'offset_end': 9058, 'content': 'function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155._batchMint', 'start_line': 244, 'end_line': 266, 'offset_start': 9064, 'offset_end': 9878, 'content': 'function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155._batchBurn', 'start_line': 267, 'end_line': 281, 'offset_start': 9884, 'offset_end': 10364, 'content': 'function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155._burn', 'start_line': 282, 'end_line': 289, 'offset_start': 10370, 'offset_end': 10590, 'content': 'function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155TokenReceiver.onERC1155Received', 'start_line': 292, 'end_line': 300, 'offset_start': 10639, 'offset_end': 10868, 'content': 'function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }', 'contract_name': 'ERC1155TokenReceiver', 'contract_code': '{\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155TokenReceiver.onERC1155BatchReceived', 'start_line': 301, 'end_line': 309, 'offset_start': 10874, 'offset_end': 11135, 'content': 'function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }', 'contract_name': 'ERC1155TokenReceiver', 'contract_code': '{\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Receiver.onERC721Received', 'start_line': 313, 'end_line': 318, 'offset_start': 11195, 'offset_end': 11354, 'content': 'function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);', 'contract_name': 'IERC721Receiver', 'contract_code': '{\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'V3Path.hasMultiplePools', 'start_line': 325, 'end_line': 327, 'offset_start': 11535, 'offset_end': 11687, 'content': 'function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }', 'contract_name': 'V3Path', 'contract_code': '{\n    using BytesLib for bytes;\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'V3Path.decodeFirstPool', 'start_line': 328, 'end_line': 330, 'offset_start': 11693, 'offset_end': 11824, 'content': 'function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }', 'contract_name': 'V3Path', 'contract_code': '{\n    using BytesLib for bytes;\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'V3Path.getFirstPool', 'start_line': 331, 'end_line': 333, 'offset_start': 11830, 'offset_end': 11965, 'content': 'function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }', 'contract_name': 'V3Path', 'contract_code': '{\n    using BytesLib for bytes;\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'V3Path.decodeFirstToken', 'start_line': 334, 'end_line': 336, 'offset_start': 11971, 'offset_end': 12098, 'content': 'function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }', 'contract_name': 'V3Path', 'contract_code': '{\n    using BytesLib for bytes;\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'V3Path.skipToken', 'start_line': 337, 'end_line': 339, 'offset_start': 12104, 'offset_end': 12242, 'content': 'function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }', 'contract_name': 'V3Path', 'contract_code': '{\n    using BytesLib for bytes;\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniversalRouter.execute', 'start_line': 350, 'end_line': 350, 'offset_start': 12761, 'offset_end': 12862, 'content': 'function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline) external payable;', 'contract_name': 'IUniversalRouter', 'contract_code': '{\n    error ExecutionFailed(uint256 commandIndex, bytes message);\n    error ETHNotAccepted();\n    error TransactionDeadlinePassed();\n    error LengthMismatch();\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline) external payable;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.tor', 'start_line': 365, 'end_line': 375, 'offset_start': 13475, 'offset_end': 13765, 'content': 'constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.approve', 'start_line': 376, 'end_line': 380, 'offset_start': 13771, 'offset_end': 13979, 'content': 'function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.transfer', 'start_line': 381, 'end_line': 388, 'offset_start': 13985, 'offset_end': 14243, 'content': 'function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.transferFrom', 'start_line': 389, 'end_line': 402, 'offset_start': 14249, 'offset_end': 14689, 'content': 'function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.permit', 'start_line': 403, 'end_line': 441, 'offset_start': 14695, 'offset_end': 16043, 'content': 'function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.DOMAIN_SEPARATOR', 'start_line': 442, 'end_line': 444, 'offset_start': 16049, 'offset_end': 16225, 'content': 'function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.computeDomainSeparator', 'start_line': 445, 'end_line': 456, 'offset_start': 16231, 'offset_end': 16676, 'content': 'function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20._mint', 'start_line': 457, 'end_line': 463, 'offset_start': 16682, 'offset_end': 16893, 'content': 'function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20._burn', 'start_line': 464, 'end_line': 470, 'offset_start': 16899, 'offset_end': 17116, 'content': 'function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Permit2Payments.permit2TransferFrom', 'start_line': 481, 'end_line': 483, 'offset_start': 17574, 'offset_end': 17730, 'content': 'function permit2TransferFrom(address token, address from, address to, uint160 amount) internal {\n        PERMIT2.transferFrom(from, to, amount, token);\n    }', 'contract_name': 'Permit2Payments', 'contract_code': '{\n    using SafeCast160 for uint256;\n    error FromAddressIsNotOwner();\n    function permit2TransferFrom(address token, address from, address to, uint160 amount) internal {\n        PERMIT2.transferFrom(from, to, amount, token);\n    }\n    function permit2TransferFrom(IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails, address owner)\n        internal\n    {\n        uint256 batchLength = batchDetails.length;\n        for (uint256 i = 0; i < batchLength; ++i) {\n            if (batchDetails[i].from != owner) revert FromAddressIsNotOwner();\n        }\n        PERMIT2.transferFrom(batchDetails);\n    }\n    function payOrPermit2Transfer(address token, address payer, address recipient, uint256 amount) internal {\n        if (payer == address(this)) pay(token, recipient, amount);\n        else permit2TransferFrom(token, payer, recipient, amount.toUint160());\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Permit2Payments.permit2TransferFrom', 'start_line': 484, 'end_line': 492, 'offset_start': 17736, 'offset_end': 18110, 'content': 'function permit2TransferFrom(IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails, address owner)\n        internal\n    {\n        uint256 batchLength = batchDetails.length;\n        for (uint256 i = 0; i < batchLength; ++i) {\n            if (batchDetails[i].from != owner) revert FromAddressIsNotOwner();\n        }\n        PERMIT2.transferFrom(batchDetails);\n    }', 'contract_name': 'Permit2Payments', 'contract_code': '{\n    using SafeCast160 for uint256;\n    error FromAddressIsNotOwner();\n    function permit2TransferFrom(address token, address from, address to, uint160 amount) internal {\n        PERMIT2.transferFrom(from, to, amount, token);\n    }\n    function permit2TransferFrom(IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails, address owner)\n        internal\n    {\n        uint256 batchLength = batchDetails.length;\n        for (uint256 i = 0; i < batchLength; ++i) {\n            if (batchDetails[i].from != owner) revert FromAddressIsNotOwner();\n        }\n        PERMIT2.transferFrom(batchDetails);\n    }\n    function payOrPermit2Transfer(address token, address payer, address recipient, uint256 amount) internal {\n        if (payer == address(this)) pay(token, recipient, amount);\n        else permit2TransferFrom(token, payer, recipient, amount.toUint160());\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Permit2Payments.payOrPermit2Transfer', 'start_line': 493, 'end_line': 496, 'offset_start': 18116, 'offset_end': 18372, 'content': 'function payOrPermit2Transfer(address token, address payer, address recipient, uint256 amount) internal {\n        if (payer == address(this)) pay(token, recipient, amount);\n        else permit2TransferFrom(token, payer, recipient, amount.toUint160());\n    }', 'contract_name': 'Permit2Payments', 'contract_code': '{\n    using SafeCast160 for uint256;\n    error FromAddressIsNotOwner();\n    function permit2TransferFrom(address token, address from, address to, uint160 amount) internal {\n        PERMIT2.transferFrom(from, to, amount, token);\n    }\n    function permit2TransferFrom(IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails, address owner)\n        internal\n    {\n        uint256 batchLength = batchDetails.length;\n        for (uint256 i = 0; i < batchLength; ++i) {\n            if (batchDetails[i].from != owner) revert FromAddressIsNotOwner();\n        }\n        PERMIT2.transferFrom(batchDetails);\n    }\n    function payOrPermit2Transfer(address token, address payer, address recipient, uint256 amount) internal {\n        if (payer == address(this)) pay(token, recipient, amount);\n        else permit2TransferFrom(token, payer, recipient, amount.toUint160());\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'V3SwapRouter.uniswapV3SwapCallback', 'start_line': 522, 'end_line': 541, 'offset_start': 19691, 'offset_end': 20830, 'content': 'function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {\n        if (amount0Delta <= 0 && amount1Delta <= 0) revert V3InvalidSwap(); \n        (, address payer) = abi.decode(data, (bytes, address));\n        bytes calldata path = data.toBytes(0);\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        if (computePoolAddress(tokenIn, tokenOut, fee) != msg.sender) revert V3InvalidCaller();\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            payOrPermit2Transfer(tokenIn, payer, msg.sender, amountToPay);\n        } else {\n            if (path.hasMultiplePools()) {\n                path = path.skipToken();\n                _swap(-amountToPay.toInt256(), msg.sender, path, payer, false);\n            } else {\n                if (amountToPay > maxAmountInCached) revert V3TooMuchRequested();\n                payOrPermit2Transfer(tokenOut, payer, msg.sender, amountToPay);\n            }\n        }\n    }', 'contract_name': 'V3SwapRouter', 'contract_code': "{\n    using V3Path for bytes;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n    error V3InvalidSwap();\n    error V3TooLittleReceived();\n    error V3TooMuchRequested();\n    error V3InvalidAmountOut();\n    error V3InvalidCaller();\n    uint256 private constant DEFAULT_MAX_AMOUNT_IN = type(uint256).max;\n    uint256 private maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {\n        if (amount0Delta <= 0 && amount1Delta <= 0) revert V3InvalidSwap(); \n        (, address payer) = abi.decode(data, (bytes, address));\n        bytes calldata path = data.toBytes(0);\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        if (computePoolAddress(tokenIn, tokenOut, fee) != msg.sender) revert V3InvalidCaller();\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            payOrPermit2Transfer(tokenIn, payer, msg.sender, amountToPay);\n        } else {\n            if (path.hasMultiplePools()) {\n                path = path.skipToken();\n                _swap(-amountToPay.toInt256(), msg.sender, path, payer, false);\n            } else {\n                if (amountToPay > maxAmountInCached) revert V3TooMuchRequested();\n                payOrPermit2Transfer(tokenOut, payer, msg.sender, amountToPay);\n            }\n        }\n    }\n    function v3SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        if (amountIn == Constants.CONTRACT_BALANCE) {\n            address tokenIn = path.decodeFirstToken();\n            amountIn = ERC20(tokenIn).balanceOf(address(this));\n        }\n        uint256 amountOut;\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n            (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) = _swap(\n                amountIn.toInt256(),\n                hasMultiplePools ? address(this) : recipient, \n                path.getFirstPool(), \n                payer, \n                true\n            );\n            amountIn = uint256(-(zeroForOne ? amount1Delta : amount0Delta));\n            if (hasMultiplePools) {\n                payer = address(this);\n                path = path.skipToken();\n            } else {\n                amountOut = amountIn;\n                break;\n            }\n        }\n        if (amountOut < amountOutMinimum) revert V3TooLittleReceived();\n    }\n    function v3SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        maxAmountInCached = amountInMaximum;\n        (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) =\n            _swap(-amountOut.toInt256(), recipient, path, payer, false);\n        uint256 amountOutReceived = zeroForOne ? uint256(-amount1Delta) : uint256(-amount0Delta);\n        if (amountOutReceived != amountOut) revert V3InvalidAmountOut();\n        maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    }\n    function _swap(int256 amount, address recipient, bytes calldata path, address payer, bool isExactIn)\n        private\n        returns (int256 amount0Delta, int256 amount1Delta, bool zeroForOne)\n    {\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        zeroForOne = isExactIn ? tokenIn < tokenOut : tokenOut < tokenIn;\n        (amount0Delta, amount1Delta) = IUniswapV3Pool(computePoolAddress(tokenIn, tokenOut, fee)).swap(\n            recipient,\n            zeroForOne,\n            amount,\n            (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1),\n            abi.encode(path, payer)\n        );\n    }\n    function computePoolAddress(address tokenA, address tokenB, uint24 fee) private view returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            UNISWAP_V3_FACTORY,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            UNISWAP_V3_POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'V3SwapRouter.v3SwapExactInput', 'start_line': 542, 'end_line': 573, 'offset_start': 20836, 'offset_end': 21966, 'content': 'function v3SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        if (amountIn == Constants.CONTRACT_BALANCE) {\n            address tokenIn = path.decodeFirstToken();\n            amountIn = ERC20(tokenIn).balanceOf(address(this));\n        }\n        uint256 amountOut;\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n            (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) = _swap(\n                amountIn.toInt256(),\n                hasMultiplePools ? address(this) : recipient, \n                path.getFirstPool(), \n                payer, \n                true\n            );\n            amountIn = uint256(-(zeroForOne ? amount1Delta : amount0Delta));\n            if (hasMultiplePools) {\n                payer = address(this);\n                path = path.skipToken();\n            } else {\n                amountOut = amountIn;\n                break;\n            }\n        }\n        if (amountOut < amountOutMinimum) revert V3TooLittleReceived();\n    }', 'contract_name': 'V3SwapRouter', 'contract_code': "{\n    using V3Path for bytes;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n    error V3InvalidSwap();\n    error V3TooLittleReceived();\n    error V3TooMuchRequested();\n    error V3InvalidAmountOut();\n    error V3InvalidCaller();\n    uint256 private constant DEFAULT_MAX_AMOUNT_IN = type(uint256).max;\n    uint256 private maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {\n        if (amount0Delta <= 0 && amount1Delta <= 0) revert V3InvalidSwap(); \n        (, address payer) = abi.decode(data, (bytes, address));\n        bytes calldata path = data.toBytes(0);\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        if (computePoolAddress(tokenIn, tokenOut, fee) != msg.sender) revert V3InvalidCaller();\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            payOrPermit2Transfer(tokenIn, payer, msg.sender, amountToPay);\n        } else {\n            if (path.hasMultiplePools()) {\n                path = path.skipToken();\n                _swap(-amountToPay.toInt256(), msg.sender, path, payer, false);\n            } else {\n                if (amountToPay > maxAmountInCached) revert V3TooMuchRequested();\n                payOrPermit2Transfer(tokenOut, payer, msg.sender, amountToPay);\n            }\n        }\n    }\n    function v3SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        if (amountIn == Constants.CONTRACT_BALANCE) {\n            address tokenIn = path.decodeFirstToken();\n            amountIn = ERC20(tokenIn).balanceOf(address(this));\n        }\n        uint256 amountOut;\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n            (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) = _swap(\n                amountIn.toInt256(),\n                hasMultiplePools ? address(this) : recipient, \n                path.getFirstPool(), \n                payer, \n                true\n            );\n            amountIn = uint256(-(zeroForOne ? amount1Delta : amount0Delta));\n            if (hasMultiplePools) {\n                payer = address(this);\n                path = path.skipToken();\n            } else {\n                amountOut = amountIn;\n                break;\n            }\n        }\n        if (amountOut < amountOutMinimum) revert V3TooLittleReceived();\n    }\n    function v3SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        maxAmountInCached = amountInMaximum;\n        (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) =\n            _swap(-amountOut.toInt256(), recipient, path, payer, false);\n        uint256 amountOutReceived = zeroForOne ? uint256(-amount1Delta) : uint256(-amount0Delta);\n        if (amountOutReceived != amountOut) revert V3InvalidAmountOut();\n        maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    }\n    function _swap(int256 amount, address recipient, bytes calldata path, address payer, bool isExactIn)\n        private\n        returns (int256 amount0Delta, int256 amount1Delta, bool zeroForOne)\n    {\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        zeroForOne = isExactIn ? tokenIn < tokenOut : tokenOut < tokenIn;\n        (amount0Delta, amount1Delta) = IUniswapV3Pool(computePoolAddress(tokenIn, tokenOut, fee)).swap(\n            recipient,\n            zeroForOne,\n            amount,\n            (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1),\n            abi.encode(path, payer)\n        );\n    }\n    function computePoolAddress(address tokenA, address tokenB, uint24 fee) private view returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            UNISWAP_V3_FACTORY,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            UNISWAP_V3_POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'V3SwapRouter.v3SwapExactOutput', 'start_line': 574, 'end_line': 587, 'offset_start': 21972, 'offset_end': 22569, 'content': 'function v3SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        maxAmountInCached = amountInMaximum;\n        (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) =\n            _swap(-amountOut.toInt256(), recipient, path, payer, false);\n        uint256 amountOutReceived = zeroForOne ? uint256(-amount1Delta) : uint256(-amount0Delta);\n        if (amountOutReceived != amountOut) revert V3InvalidAmountOut();\n        maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    }', 'contract_name': 'V3SwapRouter', 'contract_code': "{\n    using V3Path for bytes;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n    error V3InvalidSwap();\n    error V3TooLittleReceived();\n    error V3TooMuchRequested();\n    error V3InvalidAmountOut();\n    error V3InvalidCaller();\n    uint256 private constant DEFAULT_MAX_AMOUNT_IN = type(uint256).max;\n    uint256 private maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {\n        if (amount0Delta <= 0 && amount1Delta <= 0) revert V3InvalidSwap(); \n        (, address payer) = abi.decode(data, (bytes, address));\n        bytes calldata path = data.toBytes(0);\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        if (computePoolAddress(tokenIn, tokenOut, fee) != msg.sender) revert V3InvalidCaller();\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            payOrPermit2Transfer(tokenIn, payer, msg.sender, amountToPay);\n        } else {\n            if (path.hasMultiplePools()) {\n                path = path.skipToken();\n                _swap(-amountToPay.toInt256(), msg.sender, path, payer, false);\n            } else {\n                if (amountToPay > maxAmountInCached) revert V3TooMuchRequested();\n                payOrPermit2Transfer(tokenOut, payer, msg.sender, amountToPay);\n            }\n        }\n    }\n    function v3SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        if (amountIn == Constants.CONTRACT_BALANCE) {\n            address tokenIn = path.decodeFirstToken();\n            amountIn = ERC20(tokenIn).balanceOf(address(this));\n        }\n        uint256 amountOut;\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n            (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) = _swap(\n                amountIn.toInt256(),\n                hasMultiplePools ? address(this) : recipient, \n                path.getFirstPool(), \n                payer, \n                true\n            );\n            amountIn = uint256(-(zeroForOne ? amount1Delta : amount0Delta));\n            if (hasMultiplePools) {\n                payer = address(this);\n                path = path.skipToken();\n            } else {\n                amountOut = amountIn;\n                break;\n            }\n        }\n        if (amountOut < amountOutMinimum) revert V3TooLittleReceived();\n    }\n    function v3SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        maxAmountInCached = amountInMaximum;\n        (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) =\n            _swap(-amountOut.toInt256(), recipient, path, payer, false);\n        uint256 amountOutReceived = zeroForOne ? uint256(-amount1Delta) : uint256(-amount0Delta);\n        if (amountOutReceived != amountOut) revert V3InvalidAmountOut();\n        maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    }\n    function _swap(int256 amount, address recipient, bytes calldata path, address payer, bool isExactIn)\n        private\n        returns (int256 amount0Delta, int256 amount1Delta, bool zeroForOne)\n    {\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        zeroForOne = isExactIn ? tokenIn < tokenOut : tokenOut < tokenIn;\n        (amount0Delta, amount1Delta) = IUniswapV3Pool(computePoolAddress(tokenIn, tokenOut, fee)).swap(\n            recipient,\n            zeroForOne,\n            amount,\n            (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1),\n            abi.encode(path, payer)\n        );\n    }\n    function computePoolAddress(address tokenA, address tokenB, uint24 fee) private view returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            UNISWAP_V3_FACTORY,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            UNISWAP_V3_POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'V3SwapRouter._swap', 'start_line': 588, 'end_line': 601, 'offset_start': 22575, 'offset_end': 23220, 'content': 'function _swap(int256 amount, address recipient, bytes calldata path, address payer, bool isExactIn)\n        private\n        returns (int256 amount0Delta, int256 amount1Delta, bool zeroForOne)\n    {\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        zeroForOne = isExactIn ? tokenIn < tokenOut : tokenOut < tokenIn;\n        (amount0Delta, amount1Delta) = IUniswapV3Pool(computePoolAddress(tokenIn, tokenOut, fee)).swap(\n            recipient,\n            zeroForOne,\n            amount,\n            (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1),\n            abi.encode(path, payer)\n        );\n    }', 'contract_name': 'V3SwapRouter', 'contract_code': "{\n    using V3Path for bytes;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n    error V3InvalidSwap();\n    error V3TooLittleReceived();\n    error V3TooMuchRequested();\n    error V3InvalidAmountOut();\n    error V3InvalidCaller();\n    uint256 private constant DEFAULT_MAX_AMOUNT_IN = type(uint256).max;\n    uint256 private maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {\n        if (amount0Delta <= 0 && amount1Delta <= 0) revert V3InvalidSwap(); \n        (, address payer) = abi.decode(data, (bytes, address));\n        bytes calldata path = data.toBytes(0);\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        if (computePoolAddress(tokenIn, tokenOut, fee) != msg.sender) revert V3InvalidCaller();\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            payOrPermit2Transfer(tokenIn, payer, msg.sender, amountToPay);\n        } else {\n            if (path.hasMultiplePools()) {\n                path = path.skipToken();\n                _swap(-amountToPay.toInt256(), msg.sender, path, payer, false);\n            } else {\n                if (amountToPay > maxAmountInCached) revert V3TooMuchRequested();\n                payOrPermit2Transfer(tokenOut, payer, msg.sender, amountToPay);\n            }\n        }\n    }\n    function v3SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        if (amountIn == Constants.CONTRACT_BALANCE) {\n            address tokenIn = path.decodeFirstToken();\n            amountIn = ERC20(tokenIn).balanceOf(address(this));\n        }\n        uint256 amountOut;\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n            (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) = _swap(\n                amountIn.toInt256(),\n                hasMultiplePools ? address(this) : recipient, \n                path.getFirstPool(), \n                payer, \n                true\n            );\n            amountIn = uint256(-(zeroForOne ? amount1Delta : amount0Delta));\n            if (hasMultiplePools) {\n                payer = address(this);\n                path = path.skipToken();\n            } else {\n                amountOut = amountIn;\n                break;\n            }\n        }\n        if (amountOut < amountOutMinimum) revert V3TooLittleReceived();\n    }\n    function v3SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        maxAmountInCached = amountInMaximum;\n        (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) =\n            _swap(-amountOut.toInt256(), recipient, path, payer, false);\n        uint256 amountOutReceived = zeroForOne ? uint256(-amount1Delta) : uint256(-amount0Delta);\n        if (amountOutReceived != amountOut) revert V3InvalidAmountOut();\n        maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    }\n    function _swap(int256 amount, address recipient, bytes calldata path, address payer, bool isExactIn)\n        private\n        returns (int256 amount0Delta, int256 amount1Delta, bool zeroForOne)\n    {\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        zeroForOne = isExactIn ? tokenIn < tokenOut : tokenOut < tokenIn;\n        (amount0Delta, amount1Delta) = IUniswapV3Pool(computePoolAddress(tokenIn, tokenOut, fee)).swap(\n            recipient,\n            zeroForOne,\n            amount,\n            (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1),\n            abi.encode(path, payer)\n        );\n    }\n    function computePoolAddress(address tokenA, address tokenB, uint24 fee) private view returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            UNISWAP_V3_FACTORY,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            UNISWAP_V3_POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'V3SwapRouter.computePoolAddress', 'start_line': 602, 'end_line': 618, 'offset_start': 23226, 'offset_end': 23856, 'content': "function computePoolAddress(address tokenA, address tokenB, uint24 fee) private view returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            UNISWAP_V3_FACTORY,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            UNISWAP_V3_POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }", 'contract_name': 'V3SwapRouter', 'contract_code': "{\n    using V3Path for bytes;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n    error V3InvalidSwap();\n    error V3TooLittleReceived();\n    error V3TooMuchRequested();\n    error V3InvalidAmountOut();\n    error V3InvalidCaller();\n    uint256 private constant DEFAULT_MAX_AMOUNT_IN = type(uint256).max;\n    uint256 private maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {\n        if (amount0Delta <= 0 && amount1Delta <= 0) revert V3InvalidSwap(); \n        (, address payer) = abi.decode(data, (bytes, address));\n        bytes calldata path = data.toBytes(0);\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        if (computePoolAddress(tokenIn, tokenOut, fee) != msg.sender) revert V3InvalidCaller();\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            payOrPermit2Transfer(tokenIn, payer, msg.sender, amountToPay);\n        } else {\n            if (path.hasMultiplePools()) {\n                path = path.skipToken();\n                _swap(-amountToPay.toInt256(), msg.sender, path, payer, false);\n            } else {\n                if (amountToPay > maxAmountInCached) revert V3TooMuchRequested();\n                payOrPermit2Transfer(tokenOut, payer, msg.sender, amountToPay);\n            }\n        }\n    }\n    function v3SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        if (amountIn == Constants.CONTRACT_BALANCE) {\n            address tokenIn = path.decodeFirstToken();\n            amountIn = ERC20(tokenIn).balanceOf(address(this));\n        }\n        uint256 amountOut;\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n            (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) = _swap(\n                amountIn.toInt256(),\n                hasMultiplePools ? address(this) : recipient, \n                path.getFirstPool(), \n                payer, \n                true\n            );\n            amountIn = uint256(-(zeroForOne ? amount1Delta : amount0Delta));\n            if (hasMultiplePools) {\n                payer = address(this);\n                path = path.skipToken();\n            } else {\n                amountOut = amountIn;\n                break;\n            }\n        }\n        if (amountOut < amountOutMinimum) revert V3TooLittleReceived();\n    }\n    function v3SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        maxAmountInCached = amountInMaximum;\n        (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) =\n            _swap(-amountOut.toInt256(), recipient, path, payer, false);\n        uint256 amountOutReceived = zeroForOne ? uint256(-amount1Delta) : uint256(-amount0Delta);\n        if (amountOutReceived != amountOut) revert V3InvalidAmountOut();\n        maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    }\n    function _swap(int256 amount, address recipient, bytes calldata path, address payer, bool isExactIn)\n        private\n        returns (int256 amount0Delta, int256 amount1Delta, bool zeroForOne)\n    {\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        zeroForOne = isExactIn ? tokenIn < tokenOut : tokenOut < tokenIn;\n        (amount0Delta, amount1Delta) = IUniswapV3Pool(computePoolAddress(tokenIn, tokenOut, fee)).swap(\n            recipient,\n            zeroForOne,\n            amount,\n            (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1),\n            abi.encode(path, payer)\n        );\n    }\n    function computePoolAddress(address tokenA, address tokenB, uint24 fee) private view returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            UNISWAP_V3_FACTORY,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            UNISWAP_V3_POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.tokenURI', 'start_line': 627, 'end_line': 627, 'offset_start': 24226, 'offset_end': 24299, 'content': 'function tokenURI(uint256 id) public view virtual returns (string memory);', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.ownerOf', 'start_line': 630, 'end_line': 632, 'offset_start': 24409, 'offset_end': 24557, 'content': 'function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.balanceOf', 'start_line': 633, 'end_line': 636, 'offset_start': 24563, 'offset_end': 24729, 'content': 'function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.tor', 'start_line': 639, 'end_line': 642, 'offset_start': 24861, 'offset_end': 24971, 'content': 'constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.approve', 'start_line': 643, 'end_line': 648, 'offset_start': 24977, 'offset_end': 25255, 'content': 'function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.setApprovalForAll', 'start_line': 649, 'end_line': 652, 'offset_start': 25261, 'offset_end': 25462, 'content': 'function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.transferFrom', 'start_line': 653, 'end_line': 671, 'offset_start': 25468, 'offset_end': 26036, 'content': 'function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.safeTransferFrom', 'start_line': 672, 'end_line': 684, 'offset_start': 26042, 'offset_end': 26436, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.safeTransferFrom', 'start_line': 685, 'end_line': 698, 'offset_start': 26442, 'offset_end': 26867, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.supportsInterface', 'start_line': 699, 'end_line': 704, 'offset_start': 26873, 'offset_end': 27100, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._mint', 'start_line': 705, 'end_line': 713, 'offset_start': 27106, 'offset_end': 27417, 'content': 'function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._burn', 'start_line': 714, 'end_line': 723, 'offset_start': 27423, 'offset_end': 27733, 'content': 'function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._safeMint', 'start_line': 724, 'end_line': 732, 'offset_start': 27739, 'offset_end': 28077, 'content': 'function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._safeMint', 'start_line': 733, 'end_line': 745, 'offset_start': 28083, 'offset_end': 28472, 'content': 'function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721TokenReceiver.onERC721Received', 'start_line': 748, 'end_line': 755, 'offset_start': 28520, 'offset_end': 28729, 'content': 'function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }', 'contract_name': 'ERC721TokenReceiver', 'contract_code': '{\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'RewardsCollector.collectRewards', 'start_line': 766, 'end_line': 772, 'offset_start': 29192, 'offset_end': 29563, 'content': 'function collectRewards(bytes calldata looksRareClaim) external {\n        (bool success,) = LOOKS_RARE_REWARDS_DISTRIBUTOR.call(looksRareClaim);\n        if (!success) revert UnableToClaim();\n        uint256 balance = LOOKS_RARE_TOKEN.balanceOf(address(this));\n        LOOKS_RARE_TOKEN.transfer(ROUTER_REWARDS_DISTRIBUTOR, balance);\n        emit RewardsSent(balance);\n    }', 'contract_name': 'RewardsCollector', 'contract_code': '{\n    using SafeTransferLib for ERC20;\n    event RewardsSent(uint256 amount);\n    error UnableToClaim();\n    function collectRewards(bytes calldata looksRareClaim) external {\n        (bool success,) = LOOKS_RARE_REWARDS_DISTRIBUTOR.call(looksRareClaim);\n        if (!success) revert UnableToClaim();\n        uint256 balance = LOOKS_RARE_TOKEN.balanceOf(address(this));\n        LOOKS_RARE_TOKEN.transfer(ROUTER_REWARDS_DISTRIBUTOR, balance);\n        emit RewardsSent(balance);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IAllowanceTransfer.allowance', 'start_line': 825, 'end_line': 825, 'offset_start': 31001, 'offset_end': 31094, 'content': 'function allowance(address, address, address) external view returns (uint160, uint48, uint48);', 'contract_name': 'IAllowanceTransfer', 'contract_code': '{\n    error AllowanceExpired(uint256 deadline);\n    error InsufficientAllowance(uint256 amount);\n    error ExcessiveInvalidation();\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n    event Lockdown(address indexed owner, address token, address spender);\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PermitBatch {\n        PermitDetails[] details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct TokenSpenderPair {\n        address token;\n        address spender;\n    }\n    struct AllowanceTransferDetails {\n        address from;\n        address to;\n        uint160 amount;\n        address token;\n    }\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IAllowanceTransfer.approve', 'start_line': 826, 'end_line': 826, 'offset_start': 31100, 'offset_end': 31192, 'content': 'function approve(address token, address spender, uint160 amount, uint48 expiration) external;', 'contract_name': 'IAllowanceTransfer', 'contract_code': '{\n    error AllowanceExpired(uint256 deadline);\n    error InsufficientAllowance(uint256 amount);\n    error ExcessiveInvalidation();\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n    event Lockdown(address indexed owner, address token, address spender);\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PermitBatch {\n        PermitDetails[] details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct TokenSpenderPair {\n        address token;\n        address spender;\n    }\n    struct AllowanceTransferDetails {\n        address from;\n        address to;\n        uint160 amount;\n        address token;\n    }\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IAllowanceTransfer.permit', 'start_line': 827, 'end_line': 827, 'offset_start': 31198, 'offset_end': 31297, 'content': 'function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;', 'contract_name': 'IAllowanceTransfer', 'contract_code': '{\n    error AllowanceExpired(uint256 deadline);\n    error InsufficientAllowance(uint256 amount);\n    error ExcessiveInvalidation();\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n    event Lockdown(address indexed owner, address token, address spender);\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PermitBatch {\n        PermitDetails[] details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct TokenSpenderPair {\n        address token;\n        address spender;\n    }\n    struct AllowanceTransferDetails {\n        address from;\n        address to;\n        uint160 amount;\n        address token;\n    }\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IAllowanceTransfer.permit', 'start_line': 828, 'end_line': 828, 'offset_start': 31303, 'offset_end': 31400, 'content': 'function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;', 'contract_name': 'IAllowanceTransfer', 'contract_code': '{\n    error AllowanceExpired(uint256 deadline);\n    error InsufficientAllowance(uint256 amount);\n    error ExcessiveInvalidation();\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n    event Lockdown(address indexed owner, address token, address spender);\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PermitBatch {\n        PermitDetails[] details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct TokenSpenderPair {\n        address token;\n        address spender;\n    }\n    struct AllowanceTransferDetails {\n        address from;\n        address to;\n        uint160 amount;\n        address token;\n    }\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IAllowanceTransfer.transferFrom', 'start_line': 829, 'end_line': 829, 'offset_start': 31406, 'offset_end': 31493, 'content': 'function transferFrom(address from, address to, uint160 amount, address token) external;', 'contract_name': 'IAllowanceTransfer', 'contract_code': '{\n    error AllowanceExpired(uint256 deadline);\n    error InsufficientAllowance(uint256 amount);\n    error ExcessiveInvalidation();\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n    event Lockdown(address indexed owner, address token, address spender);\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PermitBatch {\n        PermitDetails[] details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct TokenSpenderPair {\n        address token;\n        address spender;\n    }\n    struct AllowanceTransferDetails {\n        address from;\n        address to;\n        uint160 amount;\n        address token;\n    }\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IAllowanceTransfer.transferFrom', 'start_line': 830, 'end_line': 830, 'offset_start': 31499, 'offset_end': 31582, 'content': 'function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;', 'contract_name': 'IAllowanceTransfer', 'contract_code': '{\n    error AllowanceExpired(uint256 deadline);\n    error InsufficientAllowance(uint256 amount);\n    error ExcessiveInvalidation();\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n    event Lockdown(address indexed owner, address token, address spender);\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PermitBatch {\n        PermitDetails[] details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct TokenSpenderPair {\n        address token;\n        address spender;\n    }\n    struct AllowanceTransferDetails {\n        address from;\n        address to;\n        uint160 amount;\n        address token;\n    }\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IAllowanceTransfer.lockdown', 'start_line': 831, 'end_line': 831, 'offset_start': 31588, 'offset_end': 31653, 'content': 'function lockdown(TokenSpenderPair[] calldata approvals) external;', 'contract_name': 'IAllowanceTransfer', 'contract_code': '{\n    error AllowanceExpired(uint256 deadline);\n    error InsufficientAllowance(uint256 amount);\n    error ExcessiveInvalidation();\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n    event Lockdown(address indexed owner, address token, address spender);\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PermitBatch {\n        PermitDetails[] details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct TokenSpenderPair {\n        address token;\n        address spender;\n    }\n    struct AllowanceTransferDetails {\n        address from;\n        address to;\n        uint160 amount;\n        address token;\n    }\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IAllowanceTransfer.invalidateNonces', 'start_line': 832, 'end_line': 832, 'offset_start': 31659, 'offset_end': 31742, 'content': 'function invalidateNonces(address token, address spender, uint48 newNonce) external;', 'contract_name': 'IAllowanceTransfer', 'contract_code': '{\n    error AllowanceExpired(uint256 deadline);\n    error InsufficientAllowance(uint256 amount);\n    error ExcessiveInvalidation();\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n    event Lockdown(address indexed owner, address token, address spender);\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PermitBatch {\n        PermitDetails[] details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct TokenSpenderPair {\n        address token;\n        address spender;\n    }\n    struct AllowanceTransferDetails {\n        address from;\n        address to;\n        uint160 amount;\n        address token;\n    }\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeCast160.toUint160', 'start_line': 877, 'end_line': 880, 'offset_start': 33498, 'offset_end': 33661, 'content': 'function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) revert UnsafeCast();\n        return uint160(value);\n    }', 'contract_name': 'SafeCast160', 'contract_code': '{\n    error UnsafeCast();\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) revert UnsafeCast();\n        return uint160(value);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeCast.toUint160', 'start_line': 884, 'end_line': 886, 'offset_start': 33713, 'offset_end': 33823, 'content': 'function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }', 'contract_name': 'SafeCast', 'contract_code': '{\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeCast.toInt128', 'start_line': 887, 'end_line': 889, 'offset_start': 33829, 'offset_end': 33935, 'content': 'function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }', 'contract_name': 'SafeCast', 'contract_code': '{\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeCast.toInt256', 'start_line': 890, 'end_line': 893, 'offset_start': 33941, 'offset_end': 34061, 'content': 'function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }', 'contract_name': 'SafeCast', 'contract_code': '{\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolImmutables.factory', 'start_line': 897, 'end_line': 897, 'offset_start': 34131, 'offset_end': 34181, 'content': 'function factory() external view returns (address);', 'contract_name': 'IUniswapV3PoolImmutables', 'contract_code': '{\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function fee() external view returns (uint24);\n    function tickSpacing() external view returns (int24);\n    function maxLiquidityPerTick() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolImmutables.token0', 'start_line': 898, 'end_line': 898, 'offset_start': 34187, 'offset_end': 34236, 'content': 'function token0() external view returns (address);', 'contract_name': 'IUniswapV3PoolImmutables', 'contract_code': '{\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function fee() external view returns (uint24);\n    function tickSpacing() external view returns (int24);\n    function maxLiquidityPerTick() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolImmutables.token1', 'start_line': 899, 'end_line': 899, 'offset_start': 34242, 'offset_end': 34291, 'content': 'function token1() external view returns (address);', 'contract_name': 'IUniswapV3PoolImmutables', 'contract_code': '{\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function fee() external view returns (uint24);\n    function tickSpacing() external view returns (int24);\n    function maxLiquidityPerTick() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolImmutables.fee', 'start_line': 900, 'end_line': 900, 'offset_start': 34297, 'offset_end': 34342, 'content': 'function fee() external view returns (uint24);', 'contract_name': 'IUniswapV3PoolImmutables', 'contract_code': '{\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function fee() external view returns (uint24);\n    function tickSpacing() external view returns (int24);\n    function maxLiquidityPerTick() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolImmutables.tickSpacing', 'start_line': 901, 'end_line': 901, 'offset_start': 34348, 'offset_end': 34400, 'content': 'function tickSpacing() external view returns (int24);', 'contract_name': 'IUniswapV3PoolImmutables', 'contract_code': '{\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function fee() external view returns (uint24);\n    function tickSpacing() external view returns (int24);\n    function maxLiquidityPerTick() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolImmutables.maxLiquidityPerTick', 'start_line': 902, 'end_line': 902, 'offset_start': 34406, 'offset_end': 34468, 'content': 'function maxLiquidityPerTick() external view returns (uint128);', 'contract_name': 'IUniswapV3PoolImmutables', 'contract_code': '{\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function fee() external view returns (uint24);\n    function tickSpacing() external view returns (int24);\n    function maxLiquidityPerTick() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolDerivedState.observe', 'start_line': 906, 'end_line': 909, 'offset_start': 34540, 'offset_end': 34719, 'content': 'function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);', 'contract_name': 'IUniswapV3PoolDerivedState', 'contract_code': '{\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolDerivedState.snapshotCumulativesInside', 'start_line': 910, 'end_line': 917, 'offset_start': 34725, 'offset_end': 34975, 'content': 'function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );', 'contract_name': 'IUniswapV3PoolDerivedState', 'contract_code': '{\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IRewardsCollector.collectRewards', 'start_line': 922, 'end_line': 922, 'offset_start': 35090, 'offset_end': 35153, 'content': 'function collectRewards(bytes calldata looksRareClaim) external;', 'contract_name': 'IRewardsCollector', 'contract_code': '{\n    function collectRewards(bytes calldata looksRareClaim) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Callbacks.onERC721Received', 'start_line': 929, 'end_line': 931, 'offset_start': 35508, 'offset_end': 35661, 'content': 'function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }', 'contract_name': 'Callbacks', 'contract_code': '{\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        pure\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || interfaceId == type(IERC721Receiver).interfaceId\n            || interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Callbacks.onERC1155Received', 'start_line': 932, 'end_line': 934, 'offset_start': 35667, 'offset_end': 35831, 'content': 'function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }', 'contract_name': 'Callbacks', 'contract_code': '{\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        pure\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || interfaceId == type(IERC721Receiver).interfaceId\n            || interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Callbacks.onERC1155BatchReceived', 'start_line': 935, 'end_line': 941, 'offset_start': 35837, 'offset_end': 36061, 'content': 'function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        pure\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }', 'contract_name': 'Callbacks', 'contract_code': '{\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        pure\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || interfaceId == type(IERC721Receiver).interfaceId\n            || interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Callbacks.supportsInterface', 'start_line': 942, 'end_line': 945, 'offset_start': 36067, 'offset_end': 36323, 'content': 'function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || interfaceId == type(IERC721Receiver).interfaceId\n            || interfaceId == type(IERC165).interfaceId;\n    }', 'contract_name': 'Callbacks', 'contract_code': '{\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        pure\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || interfaceId == type(IERC721Receiver).interfaceId\n            || interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3SwapCallback.uniswapV3SwapCallback', 'start_line': 965, 'end_line': 969, 'offset_start': 36887, 'offset_end': 37019, 'content': 'function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;', 'contract_name': 'IUniswapV3SwapCallback', 'contract_code': '{\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolState.slot0', 'start_line': 973, 'end_line': 984, 'offset_start': 37084, 'offset_end': 37400, 'content': 'function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );', 'contract_name': 'IUniswapV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolState.feeGrowthGlobal0X128', 'start_line': 985, 'end_line': 985, 'offset_start': 37406, 'offset_end': 37469, 'content': 'function feeGrowthGlobal0X128() external view returns (uint256);', 'contract_name': 'IUniswapV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolState.feeGrowthGlobal1X128', 'start_line': 986, 'end_line': 986, 'offset_start': 37475, 'offset_end': 37538, 'content': 'function feeGrowthGlobal1X128() external view returns (uint256);', 'contract_name': 'IUniswapV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolState.protocolFees', 'start_line': 987, 'end_line': 987, 'offset_start': 37544, 'offset_end': 37622, 'content': 'function protocolFees() external view returns (uint128 token0, uint128 token1);', 'contract_name': 'IUniswapV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolState.liquidity', 'start_line': 988, 'end_line': 988, 'offset_start': 37628, 'offset_end': 37680, 'content': 'function liquidity() external view returns (uint128);', 'contract_name': 'IUniswapV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolState.ticks', 'start_line': 989, 'end_line': 1001, 'offset_start': 37686, 'offset_end': 38082, 'content': 'function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );', 'contract_name': 'IUniswapV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolState.tickBitmap', 'start_line': 1002, 'end_line': 1002, 'offset_start': 38088, 'offset_end': 38159, 'content': 'function tickBitmap(int16 wordPosition) external view returns (uint256);', 'contract_name': 'IUniswapV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolState.positions', 'start_line': 1003, 'end_line': 1012, 'offset_start': 38165, 'offset_end': 38443, 'content': 'function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );', 'contract_name': 'IUniswapV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolState.observations', 'start_line': 1013, 'end_line': 1021, 'offset_start': 38449, 'offset_end': 38696, 'content': 'function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );', 'contract_name': 'IUniswapV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toAddress', 'start_line': 1027, 'end_line': 1032, 'offset_start': 38837, 'offset_end': 39092, 'content': 'function toAddress(bytes calldata _bytes) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    error SliceOutOfBounds();\n    function toAddress(bytes calldata _bytes) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }\n    function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }\n    function toLengthOffset(bytes calldata _bytes, uint256 _arg)\n        internal\n        pure\n        returns (uint256 length, uint256 offset)\n    {\n        uint256 relativeOffset;\n        assembly {\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }\n    function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toBytesArray(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toPool', 'start_line': 1033, 'end_line': 1041, 'offset_start': 39098, 'offset_end': 39538, 'content': 'function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    error SliceOutOfBounds();\n    function toAddress(bytes calldata _bytes) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }\n    function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }\n    function toLengthOffset(bytes calldata _bytes, uint256 _arg)\n        internal\n        pure\n        returns (uint256 length, uint256 offset)\n    {\n        uint256 relativeOffset;\n        assembly {\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }\n    function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toBytesArray(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toLengthOffset', 'start_line': 1042, 'end_line': 1055, 'offset_start': 39544, 'offset_end': 40077, 'content': 'function toLengthOffset(bytes calldata _bytes, uint256 _arg)\n        internal\n        pure\n        returns (uint256 length, uint256 offset)\n    {\n        uint256 relativeOffset;\n        assembly {\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    error SliceOutOfBounds();\n    function toAddress(bytes calldata _bytes) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }\n    function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }\n    function toLengthOffset(bytes calldata _bytes, uint256 _arg)\n        internal\n        pure\n        returns (uint256 length, uint256 offset)\n    {\n        uint256 relativeOffset;\n        assembly {\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }\n    function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toBytesArray(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toBytes', 'start_line': 1056, 'end_line': 1062, 'offset_start': 40083, 'offset_end': 40354, 'content': 'function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    error SliceOutOfBounds();\n    function toAddress(bytes calldata _bytes) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }\n    function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }\n    function toLengthOffset(bytes calldata _bytes, uint256 _arg)\n        internal\n        pure\n        returns (uint256 length, uint256 offset)\n    {\n        uint256 relativeOffset;\n        assembly {\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }\n    function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toBytesArray(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toAddressArray', 'start_line': 1063, 'end_line': 1069, 'offset_start': 40360, 'offset_end': 40642, 'content': 'function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    error SliceOutOfBounds();\n    function toAddress(bytes calldata _bytes) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }\n    function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }\n    function toLengthOffset(bytes calldata _bytes, uint256 _arg)\n        internal\n        pure\n        returns (uint256 length, uint256 offset)\n    {\n        uint256 relativeOffset;\n        assembly {\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }\n    function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toBytesArray(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toBytesArray', 'start_line': 1070, 'end_line': 1076, 'offset_start': 40648, 'offset_end': 40926, 'content': 'function toBytesArray(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    error SliceOutOfBounds();\n    function toAddress(bytes calldata _bytes) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }\n    function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }\n    function toLengthOffset(bytes calldata _bytes, uint256 _arg)\n        internal\n        pure\n        returns (uint256 length, uint256 offset)\n    {\n        uint256 relativeOffset;\n        assembly {\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }\n    function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toBytesArray(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'V2SwapRouter._v2Swap', 'start_line': 1090, 'end_line': 1115, 'offset_start': 41552, 'offset_end': 43097, 'content': 'function _v2Swap(address[] calldata path, address recipient, address pair) private {\n        unchecked {\n            if (path.length < 2) revert V2InvalidPath();\n            (address token0,) = UniswapV2Library.sortTokens(path[0], path[1]);\n            uint256 finalPairIndex = path.length - 1;\n            uint256 penultimatePairIndex = finalPairIndex - 1;\n            for (uint256 i; i < finalPairIndex; i++) {\n                (address input, address output) = (path[i], path[i + 1]);\n                (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n                (uint256 reserveInput, uint256 reserveOutput) =\n                    input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                uint256 amountInput = ERC20(input).balanceOf(pair) - reserveInput;\n                uint256 amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n                (uint256 amount0Out, uint256 amount1Out) =\n                    input == token0 ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n                address nextPair;\n                (nextPair, token0) = i < penultimatePairIndex\n                    ? UniswapV2Library.pairAndToken0For(\n                        UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, output, path[i + 2]\n                    )\n                    : (recipient, address(0));\n                IUniswapV2Pair(pair).swap(amount0Out, amount1Out, nextPair, new bytes(0));\n                pair = nextPair;\n            }\n        }\n    }', 'contract_name': 'V2SwapRouter', 'contract_code': '{\n    error V2TooLittleReceived();\n    error V2TooMuchRequested();\n    error V2InvalidPath();\n    function _v2Swap(address[] calldata path, address recipient, address pair) private {\n        unchecked {\n            if (path.length < 2) revert V2InvalidPath();\n            (address token0,) = UniswapV2Library.sortTokens(path[0], path[1]);\n            uint256 finalPairIndex = path.length - 1;\n            uint256 penultimatePairIndex = finalPairIndex - 1;\n            for (uint256 i; i < finalPairIndex; i++) {\n                (address input, address output) = (path[i], path[i + 1]);\n                (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n                (uint256 reserveInput, uint256 reserveOutput) =\n                    input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                uint256 amountInput = ERC20(input).balanceOf(pair) - reserveInput;\n                uint256 amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n                (uint256 amount0Out, uint256 amount1Out) =\n                    input == token0 ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n                address nextPair;\n                (nextPair, token0) = i < penultimatePairIndex\n                    ? UniswapV2Library.pairAndToken0For(\n                        UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, output, path[i + 2]\n                    )\n                    : (recipient, address(0));\n                IUniswapV2Pair(pair).swap(amount0Out, amount1Out, nextPair, new bytes(0));\n                pair = nextPair;\n            }\n        }\n    }\n    function v2SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        address firstPair =\n            UniswapV2Library.pairFor(UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, path[0], path[1]);\n        if (\n            amountIn != Constants.ALREADY_PAID \n        ) {\n            payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        }\n        ERC20 tokenOut = ERC20(path[path.length - 1]);\n        uint256 balanceBefore = tokenOut.balanceOf(recipient);\n        _v2Swap(path, recipient, firstPair);\n        uint256 amountOut = tokenOut.balanceOf(recipient) - balanceBefore;\n        if (amountOut < amountOutMinimum) revert V2TooLittleReceived();\n    }\n    function v2SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        (uint256 amountIn, address firstPair) =\n            UniswapV2Library.getAmountInMultihop(UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, amountOut, path);\n        if (amountIn > amountInMaximum) revert V2TooMuchRequested();\n        payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        _v2Swap(path, recipient, firstPair);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'V2SwapRouter.v2SwapExactInput', 'start_line': 1116, 'end_line': 1135, 'offset_start': 43103, 'offset_end': 43893, 'content': 'function v2SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        address firstPair =\n            UniswapV2Library.pairFor(UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, path[0], path[1]);\n        if (\n            amountIn != Constants.ALREADY_PAID \n        ) {\n            payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        }\n        ERC20 tokenOut = ERC20(path[path.length - 1]);\n        uint256 balanceBefore = tokenOut.balanceOf(recipient);\n        _v2Swap(path, recipient, firstPair);\n        uint256 amountOut = tokenOut.balanceOf(recipient) - balanceBefore;\n        if (amountOut < amountOutMinimum) revert V2TooLittleReceived();\n    }', 'contract_name': 'V2SwapRouter', 'contract_code': '{\n    error V2TooLittleReceived();\n    error V2TooMuchRequested();\n    error V2InvalidPath();\n    function _v2Swap(address[] calldata path, address recipient, address pair) private {\n        unchecked {\n            if (path.length < 2) revert V2InvalidPath();\n            (address token0,) = UniswapV2Library.sortTokens(path[0], path[1]);\n            uint256 finalPairIndex = path.length - 1;\n            uint256 penultimatePairIndex = finalPairIndex - 1;\n            for (uint256 i; i < finalPairIndex; i++) {\n                (address input, address output) = (path[i], path[i + 1]);\n                (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n                (uint256 reserveInput, uint256 reserveOutput) =\n                    input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                uint256 amountInput = ERC20(input).balanceOf(pair) - reserveInput;\n                uint256 amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n                (uint256 amount0Out, uint256 amount1Out) =\n                    input == token0 ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n                address nextPair;\n                (nextPair, token0) = i < penultimatePairIndex\n                    ? UniswapV2Library.pairAndToken0For(\n                        UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, output, path[i + 2]\n                    )\n                    : (recipient, address(0));\n                IUniswapV2Pair(pair).swap(amount0Out, amount1Out, nextPair, new bytes(0));\n                pair = nextPair;\n            }\n        }\n    }\n    function v2SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        address firstPair =\n            UniswapV2Library.pairFor(UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, path[0], path[1]);\n        if (\n            amountIn != Constants.ALREADY_PAID \n        ) {\n            payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        }\n        ERC20 tokenOut = ERC20(path[path.length - 1]);\n        uint256 balanceBefore = tokenOut.balanceOf(recipient);\n        _v2Swap(path, recipient, firstPair);\n        uint256 amountOut = tokenOut.balanceOf(recipient) - balanceBefore;\n        if (amountOut < amountOutMinimum) revert V2TooLittleReceived();\n    }\n    function v2SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        (uint256 amountIn, address firstPair) =\n            UniswapV2Library.getAmountInMultihop(UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, amountOut, path);\n        if (amountIn > amountInMaximum) revert V2TooMuchRequested();\n        payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        _v2Swap(path, recipient, firstPair);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'V2SwapRouter.v2SwapExactOutput', 'start_line': 1136, 'end_line': 1148, 'offset_start': 43899, 'offset_end': 44438, 'content': 'function v2SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        (uint256 amountIn, address firstPair) =\n            UniswapV2Library.getAmountInMultihop(UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, amountOut, path);\n        if (amountIn > amountInMaximum) revert V2TooMuchRequested();\n        payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        _v2Swap(path, recipient, firstPair);\n    }', 'contract_name': 'V2SwapRouter', 'contract_code': '{\n    error V2TooLittleReceived();\n    error V2TooMuchRequested();\n    error V2InvalidPath();\n    function _v2Swap(address[] calldata path, address recipient, address pair) private {\n        unchecked {\n            if (path.length < 2) revert V2InvalidPath();\n            (address token0,) = UniswapV2Library.sortTokens(path[0], path[1]);\n            uint256 finalPairIndex = path.length - 1;\n            uint256 penultimatePairIndex = finalPairIndex - 1;\n            for (uint256 i; i < finalPairIndex; i++) {\n                (address input, address output) = (path[i], path[i + 1]);\n                (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n                (uint256 reserveInput, uint256 reserveOutput) =\n                    input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                uint256 amountInput = ERC20(input).balanceOf(pair) - reserveInput;\n                uint256 amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n                (uint256 amount0Out, uint256 amount1Out) =\n                    input == token0 ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n                address nextPair;\n                (nextPair, token0) = i < penultimatePairIndex\n                    ? UniswapV2Library.pairAndToken0For(\n                        UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, output, path[i + 2]\n                    )\n                    : (recipient, address(0));\n                IUniswapV2Pair(pair).swap(amount0Out, amount1Out, nextPair, new bytes(0));\n                pair = nextPair;\n            }\n        }\n    }\n    function v2SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        address firstPair =\n            UniswapV2Library.pairFor(UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, path[0], path[1]);\n        if (\n            amountIn != Constants.ALREADY_PAID \n        ) {\n            payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        }\n        ERC20 tokenOut = ERC20(path[path.length - 1]);\n        uint256 balanceBefore = tokenOut.balanceOf(recipient);\n        _v2Swap(path, recipient, firstPair);\n        uint256 amountOut = tokenOut.balanceOf(recipient) - balanceBefore;\n        if (amountOut < amountOutMinimum) revert V2TooLittleReceived();\n    }\n    function v2SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        (uint256 amountIn, address firstPair) =\n            UniswapV2Library.getAmountInMultihop(UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, amountOut, path);\n        if (amountIn > amountInMaximum) revert V2TooMuchRequested();\n        payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        _v2Swap(path, recipient, firstPair);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeTransferLib.safeTransferETH', 'start_line': 1153, 'end_line': 1159, 'offset_start': 44540, 'offset_end': 44767, 'content': 'function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n        assembly {\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n        require(success, "ETH_TRANSFER_FAILED");\n    }', 'contract_name': 'SafeTransferLib', 'contract_code': '{\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n        assembly {\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n        require(success, "ETH_TRANSFER_FAILED");\n    }\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) \n            mstore(add(freeMemoryPointer, 36), to) \n            mstore(add(freeMemoryPointer, 68), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FROM_FAILED");\n    }\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FAILED");\n    }\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "APPROVE_FAILED");\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeTransferLib.safeTransferFrom', 'start_line': 1160, 'end_line': 1179, 'offset_start': 44773, 'offset_end': 45529, 'content': 'function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) \n            mstore(add(freeMemoryPointer, 36), to) \n            mstore(add(freeMemoryPointer, 68), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FROM_FAILED");\n    }', 'contract_name': 'SafeTransferLib', 'contract_code': '{\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n        assembly {\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n        require(success, "ETH_TRANSFER_FAILED");\n    }\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) \n            mstore(add(freeMemoryPointer, 36), to) \n            mstore(add(freeMemoryPointer, 68), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FROM_FAILED");\n    }\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FAILED");\n    }\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "APPROVE_FAILED");\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeTransferLib.safeTransfer', 'start_line': 1180, 'end_line': 1197, 'offset_start': 45535, 'offset_end': 46205, 'content': 'function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FAILED");\n    }', 'contract_name': 'SafeTransferLib', 'contract_code': '{\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n        assembly {\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n        require(success, "ETH_TRANSFER_FAILED");\n    }\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) \n            mstore(add(freeMemoryPointer, 36), to) \n            mstore(add(freeMemoryPointer, 68), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FROM_FAILED");\n    }\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FAILED");\n    }\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "APPROVE_FAILED");\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeTransferLib.safeApprove', 'start_line': 1198, 'end_line': 1215, 'offset_start': 46211, 'offset_end': 46879, 'content': 'function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "APPROVE_FAILED");\n    }', 'contract_name': 'SafeTransferLib', 'contract_code': '{\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n        assembly {\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n        require(success, "ETH_TRANSFER_FAILED");\n    }\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) \n            mstore(add(freeMemoryPointer, 36), to) \n            mstore(add(freeMemoryPointer, 68), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FROM_FAILED");\n    }\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FAILED");\n    }\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "APPROVE_FAILED");\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Payments.pay', 'start_line': 1232, 'end_line': 1241, 'offset_start': 47554, 'offset_end': 47931, 'content': 'function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }', 'contract_name': 'Payments', 'contract_code': "{\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    error InsufficientToken();\n    error InsufficientETH();\n    error InvalidBips();\n    error InvalidSpender();\n    uint256 internal constant FEE_BIPS_BASE = 10_000;\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n    function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else if (spender == Spenders.Sudoswap) spenderAddress = SUDOSWAP;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n    function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }\n    function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Payments.approveERC20', 'start_line': 1242, 'end_line': 1248, 'offset_start': 47937, 'offset_end': 48288, 'content': 'function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else if (spender == Spenders.Sudoswap) spenderAddress = SUDOSWAP;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }', 'contract_name': 'Payments', 'contract_code': "{\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    error InsufficientToken();\n    error InsufficientETH();\n    error InvalidBips();\n    error InvalidSpender();\n    uint256 internal constant FEE_BIPS_BASE = 10_000;\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n    function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else if (spender == Spenders.Sudoswap) spenderAddress = SUDOSWAP;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n    function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }\n    function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Payments.payPortion', 'start_line': 1249, 'end_line': 1260, 'offset_start': 48294, 'offset_end': 48864, 'content': 'function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }', 'contract_name': 'Payments', 'contract_code': "{\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    error InsufficientToken();\n    error InsufficientETH();\n    error InvalidBips();\n    error InvalidSpender();\n    uint256 internal constant FEE_BIPS_BASE = 10_000;\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n    function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else if (spender == Spenders.Sudoswap) spenderAddress = SUDOSWAP;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n    function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }\n    function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Payments.sweep', 'start_line': 1261, 'end_line': 1272, 'offset_start': 48870, 'offset_end': 49430, 'content': 'function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }', 'contract_name': 'Payments', 'contract_code': "{\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    error InsufficientToken();\n    error InsufficientETH();\n    error InvalidBips();\n    error InvalidSpender();\n    uint256 internal constant FEE_BIPS_BASE = 10_000;\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n    function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else if (spender == Spenders.Sudoswap) spenderAddress = SUDOSWAP;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n    function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }\n    function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Payments.sweepERC721', 'start_line': 1273, 'end_line': 1275, 'offset_start': 49436, 'offset_end': 49588, 'content': 'function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }', 'contract_name': 'Payments', 'contract_code': "{\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    error InsufficientToken();\n    error InsufficientETH();\n    error InvalidBips();\n    error InvalidSpender();\n    uint256 internal constant FEE_BIPS_BASE = 10_000;\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n    function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else if (spender == Spenders.Sudoswap) spenderAddress = SUDOSWAP;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n    function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }\n    function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Payments.sweepERC1155', 'start_line': 1276, 'end_line': 1280, 'offset_start': 49594, 'offset_end': 49927, 'content': "function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }", 'contract_name': 'Payments', 'contract_code': "{\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    error InsufficientToken();\n    error InsufficientETH();\n    error InvalidBips();\n    error InvalidSpender();\n    uint256 internal constant FEE_BIPS_BASE = 10_000;\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n    function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else if (spender == Spenders.Sudoswap) spenderAddress = SUDOSWAP;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n    function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }\n    function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Payments.wrapETH', 'start_line': 1281, 'end_line': 1293, 'offset_start': 49933, 'offset_end': 50388, 'content': 'function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }', 'contract_name': 'Payments', 'contract_code': "{\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    error InsufficientToken();\n    error InsufficientETH();\n    error InvalidBips();\n    error InvalidSpender();\n    uint256 internal constant FEE_BIPS_BASE = 10_000;\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n    function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else if (spender == Spenders.Sudoswap) spenderAddress = SUDOSWAP;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n    function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }\n    function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Payments.unwrapWETH9', 'start_line': 1294, 'end_line': 1305, 'offset_start': 50394, 'offset_end': 50793, 'content': 'function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }', 'contract_name': 'Payments', 'contract_code': "{\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    error InsufficientToken();\n    error InsufficientETH();\n    error InvalidBips();\n    error InvalidSpender();\n    uint256 internal constant FEE_BIPS_BASE = 10_000;\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n    function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else if (spender == Spenders.Sudoswap) spenderAddress = SUDOSWAP;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n    function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }\n    function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 1311, 'end_line': 1311, 'offset_start': 51004, 'offset_end': 51058, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 1312, 'end_line': 1312, 'offset_start': 51064, 'offset_end': 51131, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 1313, 'end_line': 1313, 'offset_start': 51137, 'offset_end': 51206, 'content': 'function transfer(address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 1314, 'end_line': 1314, 'offset_start': 51212, 'offset_end': 51294, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 1315, 'end_line': 1315, 'offset_start': 51300, 'offset_end': 51373, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 1316, 'end_line': 1320, 'offset_start': 51379, 'offset_end': 51496, 'content': 'function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolActions.initialize', 'start_line': 1324, 'end_line': 1324, 'offset_start': 51563, 'offset_end': 51613, 'content': 'function initialize(uint160 sqrtPriceX96) external;', 'contract_name': 'IUniswapV3PoolActions', 'contract_code': '{\n    function initialize(uint160 sqrtPriceX96) external;\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolActions.mint', 'start_line': 1325, 'end_line': 1331, 'offset_start': 51619, 'offset_end': 51820, 'content': 'function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);', 'contract_name': 'IUniswapV3PoolActions', 'contract_code': '{\n    function initialize(uint160 sqrtPriceX96) external;\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolActions.collect', 'start_line': 1332, 'end_line': 1338, 'offset_start': 51826, 'offset_end': 52045, 'content': 'function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);', 'contract_name': 'IUniswapV3PoolActions', 'contract_code': '{\n    function initialize(uint160 sqrtPriceX96) external;\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolActions.burn', 'start_line': 1339, 'end_line': 1343, 'offset_start': 52051, 'offset_end': 52196, 'content': 'function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);', 'contract_name': 'IUniswapV3PoolActions', 'contract_code': '{\n    function initialize(uint160 sqrtPriceX96) external;\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolActions.swap', 'start_line': 1344, 'end_line': 1350, 'offset_start': 52202, 'offset_end': 52419, 'content': 'function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);', 'contract_name': 'IUniswapV3PoolActions', 'contract_code': '{\n    function initialize(uint160 sqrtPriceX96) external;\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolActions.flash', 'start_line': 1351, 'end_line': 1356, 'offset_start': 52425, 'offset_end': 52560, 'content': 'function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;', 'contract_name': 'IUniswapV3PoolActions', 'contract_code': '{\n    function initialize(uint160 sqrtPriceX96) external;\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolActions.increaseObservationCardinalityNext', 'start_line': 1357, 'end_line': 1357, 'offset_start': 52566, 'offset_end': 52653, 'content': 'function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;', 'contract_name': 'IUniswapV3PoolActions', 'contract_code': '{\n    function initialize(uint160 sqrtPriceX96) external;\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.name', 'start_line': 1363, 'end_line': 1363, 'offset_start': 52867, 'offset_end': 52920, 'content': 'function name() external pure returns (string memory);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.symbol', 'start_line': 1364, 'end_line': 1364, 'offset_start': 52926, 'offset_end': 52981, 'content': 'function symbol() external pure returns (string memory);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.decimals', 'start_line': 1365, 'end_line': 1365, 'offset_start': 52987, 'offset_end': 53036, 'content': 'function decimals() external pure returns (uint8);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.totalSupply', 'start_line': 1366, 'end_line': 1366, 'offset_start': 53042, 'offset_end': 53093, 'content': 'function totalSupply() external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.balanceOf', 'start_line': 1367, 'end_line': 1367, 'offset_start': 53099, 'offset_end': 53161, 'content': 'function balanceOf(address owner) external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.allowance', 'start_line': 1368, 'end_line': 1368, 'offset_start': 53167, 'offset_end': 53246, 'content': 'function allowance(address owner, address spender) external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.approve', 'start_line': 1369, 'end_line': 1369, 'offset_start': 53252, 'offset_end': 53321, 'content': 'function approve(address spender, uint value) external returns (bool);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.transfer', 'start_line': 1370, 'end_line': 1370, 'offset_start': 53327, 'offset_end': 53392, 'content': 'function transfer(address to, uint value) external returns (bool);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.transferFrom', 'start_line': 1371, 'end_line': 1371, 'offset_start': 53398, 'offset_end': 53481, 'content': 'function transferFrom(address from, address to, uint value) external returns (bool);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.DOMAIN_SEPARATOR', 'start_line': 1372, 'end_line': 1372, 'offset_start': 53487, 'offset_end': 53546, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.PERMIT_TYPEHASH', 'start_line': 1373, 'end_line': 1373, 'offset_start': 53552, 'offset_end': 53610, 'content': 'function PERMIT_TYPEHASH() external pure returns (bytes32);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.nonces', 'start_line': 1374, 'end_line': 1374, 'offset_start': 53616, 'offset_end': 53675, 'content': 'function nonces(address owner) external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.permit', 'start_line': 1375, 'end_line': 1375, 'offset_start': 53681, 'offset_end': 53795, 'content': 'function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.MINIMUM_LIQUIDITY', 'start_line': 1387, 'end_line': 1387, 'offset_start': 54189, 'offset_end': 54246, 'content': 'function MINIMUM_LIQUIDITY() external pure returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.factory', 'start_line': 1388, 'end_line': 1388, 'offset_start': 54252, 'offset_end': 54302, 'content': 'function factory() external view returns (address);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.token0', 'start_line': 1389, 'end_line': 1389, 'offset_start': 54308, 'offset_end': 54357, 'content': 'function token0() external view returns (address);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.token1', 'start_line': 1390, 'end_line': 1390, 'offset_start': 54363, 'offset_end': 54412, 'content': 'function token1() external view returns (address);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.getReserves', 'start_line': 1391, 'end_line': 1391, 'offset_start': 54418, 'offset_end': 54526, 'content': 'function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.price0CumulativeLast', 'start_line': 1392, 'end_line': 1392, 'offset_start': 54532, 'offset_end': 54592, 'content': 'function price0CumulativeLast() external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.price1CumulativeLast', 'start_line': 1393, 'end_line': 1393, 'offset_start': 54598, 'offset_end': 54658, 'content': 'function price1CumulativeLast() external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.kLast', 'start_line': 1394, 'end_line': 1394, 'offset_start': 54664, 'offset_end': 54709, 'content': 'function kLast() external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.mint', 'start_line': 1395, 'end_line': 1395, 'offset_start': 54715, 'offset_end': 54774, 'content': 'function mint(address to) external returns (uint liquidity);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.burn', 'start_line': 1396, 'end_line': 1396, 'offset_start': 54780, 'offset_end': 54851, 'content': 'function burn(address to) external returns (uint amount0, uint amount1);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.swap', 'start_line': 1397, 'end_line': 1397, 'offset_start': 54857, 'offset_end': 54946, 'content': 'function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.skim', 'start_line': 1398, 'end_line': 1398, 'offset_start': 54952, 'offset_end': 54986, 'content': 'function skim(address to) external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.sync', 'start_line': 1399, 'end_line': 1399, 'offset_start': 54992, 'offset_end': 55016, 'content': 'function sync() external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.initialize', 'start_line': 1400, 'end_line': 1400, 'offset_start': 55022, 'offset_end': 55068, 'content': 'function initialize(address, address) external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolOwnerActions.setFeeProtocol', 'start_line': 1404, 'end_line': 1404, 'offset_start': 55140, 'offset_end': 55212, 'content': 'function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;', 'contract_name': 'IUniswapV3PoolOwnerActions', 'contract_code': '{\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3PoolOwnerActions.collectProtocol', 'start_line': 1405, 'end_line': 1409, 'offset_start': 55218, 'offset_end': 55395, 'content': 'function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);', 'contract_name': 'IUniswapV3PoolOwnerActions', 'contract_code': '{\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'UniswapV2Library.pairFor', 'start_line': 1416, 'end_line': 1423, 'offset_start': 55598, 'offset_end': 55900, 'content': 'function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }', 'contract_name': 'UniswapV2Library', 'contract_code': "{\n    error InvalidReserves();\n    error InvalidPath();\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 1000;\n        uint256 denominator = (reserveOut - amountOut) * 997;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] memory path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'UniswapV2Library.pairAndToken0For', 'start_line': 1424, 'end_line': 1432, 'offset_start': 55906, 'offset_end': 56241, 'content': 'function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }', 'contract_name': 'UniswapV2Library', 'contract_code': "{\n    error InvalidReserves();\n    error InvalidPath();\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 1000;\n        uint256 denominator = (reserveOut - amountOut) * 997;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] memory path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'UniswapV2Library.pairForPreSorted', 'start_line': 1433, 'end_line': 1447, 'offset_start': 56247, 'offset_end': 56698, 'content': "function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }", 'contract_name': 'UniswapV2Library', 'contract_code': "{\n    error InvalidReserves();\n    error InvalidPath();\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 1000;\n        uint256 denominator = (reserveOut - amountOut) * 997;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] memory path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'UniswapV2Library.pairAndReservesFor', 'start_line': 1448, 'end_line': 1457, 'offset_start': 56704, 'offset_end': 57194, 'content': 'function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }', 'contract_name': 'UniswapV2Library', 'contract_code': "{\n    error InvalidReserves();\n    error InvalidPath();\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 1000;\n        uint256 denominator = (reserveOut - amountOut) * 997;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] memory path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'UniswapV2Library.getAmountOut', 'start_line': 1458, 'end_line': 1468, 'offset_start': 57200, 'offset_end': 57647, 'content': 'function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }', 'contract_name': 'UniswapV2Library', 'contract_code': "{\n    error InvalidReserves();\n    error InvalidPath();\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 1000;\n        uint256 denominator = (reserveOut - amountOut) * 997;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] memory path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'UniswapV2Library.getAmountIn', 'start_line': 1469, 'end_line': 1478, 'offset_start': 57653, 'offset_end': 58050, 'content': 'function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 1000;\n        uint256 denominator = (reserveOut - amountOut) * 997;\n        amountIn = (numerator / denominator) + 1;\n    }', 'contract_name': 'UniswapV2Library', 'contract_code': "{\n    error InvalidReserves();\n    error InvalidPath();\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 1000;\n        uint256 denominator = (reserveOut - amountOut) * 997;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] memory path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'UniswapV2Library.getAmountInMultihop', 'start_line': 1479, 'end_line': 1492, 'offset_start': 58056, 'offset_end': 58635, 'content': 'function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] memory path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }', 'contract_name': 'UniswapV2Library', 'contract_code': "{\n    error InvalidReserves();\n    error InvalidPath();\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 1000;\n        uint256 denominator = (reserveOut - amountOut) * 997;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] memory path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'UniswapV2Library.sortTokens', 'start_line': 1493, 'end_line': 1495, 'offset_start': 58641, 'offset_end': 58836, 'content': 'function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }', 'contract_name': 'UniswapV2Library', 'contract_code': "{\n    error InvalidReserves();\n    error InvalidPath();\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 1000;\n        uint256 denominator = (reserveOut - amountOut) * 997;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] memory path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC165.supportsInterface', 'start_line': 1551, 'end_line': 1551, 'offset_start': 60387, 'offset_end': 60462, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165', 'contract_code': '{\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'LockAndMsgSender.map', 'start_line': 1583, 'end_line': 1591, 'offset_start': 61771, 'offset_end': 62068, 'content': 'function map(address recipient) internal view returns (address) {\n        if (recipient == Constants.MSG_SENDER) {\n            return lockedBy;\n        } else if (recipient == Constants.ADDRESS_THIS) {\n            return address(this);\n        } else {\n            return recipient;\n        }\n    }', 'contract_name': 'LockAndMsgSender', 'contract_code': '{\n    error ContractLocked();\n    address internal constant NOT_LOCKED_FLAG = address(1);\n    address internal lockedBy = NOT_LOCKED_FLAG;\n    modifier isNotLocked() {\n        if (msg.sender != address(this)) {\n            if (lockedBy != NOT_LOCKED_FLAG) revert ContractLocked();\n            lockedBy = msg.sender;\n            _;\n            lockedBy = NOT_LOCKED_FLAG;\n        } else {\n            _;\n        }\n    }\n    function map(address recipient) internal view returns (address) {\n        if (recipient == Constants.MSG_SENDER) {\n            return lockedBy;\n        } else if (recipient == Constants.ADDRESS_THIS) {\n            return address(this);\n        } else {\n            return recipient;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Dispatcher.dispatch', 'start_line': 1614, 'end_line': 1885, 'offset_start': 63197, 'offset_end': 78833, 'content': 'function dispatch(bytes1 commandType, bytes calldata inputs) internal returns (bool success, bytes memory output) {\n        uint256 command = uint8(commandType & Commands.COMMAND_TYPE_MASK);\n        success = true;\n        if (command < Commands.FOURTH_IF_BOUNDARY) {\n            if (command < Commands.SECOND_IF_BOUNDARY) {\n                if (command < Commands.FIRST_IF_BOUNDARY) {\n                    if (command == Commands.V3_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V3_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM) {\n                        address token;\n                        address recipient;\n                        uint160 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amount := calldataload(add(inputs.offset, 0x40))\n                        }\n                        permit2TransferFrom(token, lockedBy, map(recipient), amount);\n                    } else if (command == Commands.PERMIT2_PERMIT_BATCH) {\n                        (IAllowanceTransfer.PermitBatch memory permitBatch,) =\n                            abi.decode(inputs, (IAllowanceTransfer.PermitBatch, bytes));\n                        bytes calldata data = inputs.toBytes(1);\n                        PERMIT2.permit(lockedBy, permitBatch, data);\n                    } else if (command == Commands.SWEEP) {\n                        address token;\n                        address recipient;\n                        uint160 amountMin;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amountMin := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweep(token, map(recipient), amountMin);\n                    } else if (command == Commands.TRANSFER) {\n                        address token;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.pay(token, map(recipient), value);\n                    } else if (command == Commands.PAY_PORTION) {\n                        address token;\n                        address recipient;\n                        uint256 bips;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            bips := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.payPortion(token, map(recipient), bips);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.V2_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V2_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_PERMIT) {\n                        IAllowanceTransfer.PermitSingle calldata permitSingle;\n                        assembly {\n                            permitSingle := inputs.offset\n                        }\n                        bytes calldata data = inputs.toBytes(6); \n                        PERMIT2.permit(lockedBy, permitSingle, data);\n                    } else if (command == Commands.WRAP_ETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.wrapETH(map(recipient), amountMin);\n                    } else if (command == Commands.UNWRAP_WETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.unwrapWETH9(map(recipient), amountMin);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM_BATCH) {\n                        (IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails) =\n                            abi.decode(inputs, (IAllowanceTransfer.AllowanceTransferDetails[]));\n                        permit2TransferFrom(batchDetails, lockedBy);\n                    } else if (command == Commands.BALANCE_CHECK_ERC20) {\n                        address owner;\n                        address token;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            minBalance := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC20(token).balanceOf(owner) >= minBalance);\n                        if (!success) output = abi.encodePacked(BalanceTooLow.selector);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            } else {\n                if (command < Commands.THIRD_IF_BOUNDARY) {\n                    if (command == Commands.SEAPORT_V1_5) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_5.call{value: value}(data);\n                    } else if (command == Commands.LOOKS_RARE_V2) {\n                        uint256 value;\n                        assembly {\n                            value := calldataload(inputs.offset)\n                        }\n                        bytes calldata data = inputs.toBytes(1);\n                        (success, output) = LOOKS_RARE_V2.call{value: value}(data);\n                    } else if (command == Commands.NFTX) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = NFTX_ZAP.call{value: value}(data);\n                    } else if (command == Commands.CRYPTOPUNKS) {\n                        uint256 punkId;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            punkId := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        (success, output) = CRYPTOPUNKS.call{value: value}(\n                            abi.encodeWithSelector(ICryptoPunksMarket.buyPunk.selector, punkId)\n                        );\n                        if (success) ICryptoPunksMarket(CRYPTOPUNKS).transferPunk(map(recipient), punkId);\n                        else output = abi.encodePacked(BuyPunkFailed.selector);\n                    } else if (command == Commands.OWNER_CHECK_721) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC721(token).ownerOf(id) == owner);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC721.selector);\n                    } else if (command == Commands.OWNER_CHECK_1155) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            minBalance := calldataload(add(inputs.offset, 0x60))\n                        }\n                        success = (ERC1155(token).balanceOf(owner, id) >= minBalance);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC1155.selector);\n                    } else if (command == Commands.SWEEP_ERC721) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweepERC721(token, map(recipient), id);\n                    }\n                } else {\n                    if (command == Commands.X2Y2_721) {\n                        (success, output) = callAndTransfer721(inputs, X2Y2);\n                    } else if (command == Commands.SUDOSWAP) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SUDOSWAP.call{value: value}(data);\n                    } else if (command == Commands.NFT20) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = NFT20_ZAP.call{value: value}(data);\n                    } else if (command == Commands.X2Y2_1155) {\n                        (success, output) = callAndTransfer1155(inputs, X2Y2);\n                    } else if (command == Commands.FOUNDATION) {\n                        (success, output) = callAndTransfer721(inputs, FOUNDATION);\n                    } else if (command == Commands.SWEEP_ERC1155) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        uint256 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            amount := calldataload(add(inputs.offset, 0x60))\n                        }\n                        Payments.sweepERC1155(token, map(recipient), id, amount);\n                    } else if (command == Commands.ELEMENT_MARKET) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = ELEMENT_MARKET.call{value: value}(data);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            }\n        } else {\n            if (command == Commands.SEAPORT_V1_4) {\n                (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                (success, output) = SEAPORT_V1_4.call{value: value}(data);\n            } else if (command == Commands.EXECUTE_SUB_PLAN) {\n                bytes calldata _commands = inputs.toBytes(0);\n                bytes[] calldata _inputs = inputs.toBytesArray(1);\n                (success, output) =\n                    (address(this)).call(abi.encodeWithSelector(Dispatcher.execute.selector, _commands, _inputs));\n            } else if (command == Commands.APPROVE_ERC20) {\n                ERC20 token;\n                RouterImmutables.Spenders spender;\n                assembly {\n                    token := calldataload(inputs.offset)\n                    spender := calldataload(add(inputs.offset, 0x20))\n                }\n                Payments.approveERC20(token, spender);\n            } else {\n                revert InvalidCommandType(command);\n            }\n        }\n    }', 'contract_name': 'Dispatcher', 'contract_code': '{\n    using BytesLib for bytes;\n    error InvalidCommandType(uint256 commandType);\n    error BuyPunkFailed();\n    error InvalidOwnerERC721();\n    error InvalidOwnerERC1155();\n    error BalanceTooLow();\n    function dispatch(bytes1 commandType, bytes calldata inputs) internal returns (bool success, bytes memory output) {\n        uint256 command = uint8(commandType & Commands.COMMAND_TYPE_MASK);\n        success = true;\n        if (command < Commands.FOURTH_IF_BOUNDARY) {\n            if (command < Commands.SECOND_IF_BOUNDARY) {\n                if (command < Commands.FIRST_IF_BOUNDARY) {\n                    if (command == Commands.V3_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V3_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM) {\n                        address token;\n                        address recipient;\n                        uint160 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amount := calldataload(add(inputs.offset, 0x40))\n                        }\n                        permit2TransferFrom(token, lockedBy, map(recipient), amount);\n                    } else if (command == Commands.PERMIT2_PERMIT_BATCH) {\n                        (IAllowanceTransfer.PermitBatch memory permitBatch,) =\n                            abi.decode(inputs, (IAllowanceTransfer.PermitBatch, bytes));\n                        bytes calldata data = inputs.toBytes(1);\n                        PERMIT2.permit(lockedBy, permitBatch, data);\n                    } else if (command == Commands.SWEEP) {\n                        address token;\n                        address recipient;\n                        uint160 amountMin;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amountMin := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweep(token, map(recipient), amountMin);\n                    } else if (command == Commands.TRANSFER) {\n                        address token;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.pay(token, map(recipient), value);\n                    } else if (command == Commands.PAY_PORTION) {\n                        address token;\n                        address recipient;\n                        uint256 bips;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            bips := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.payPortion(token, map(recipient), bips);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.V2_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V2_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_PERMIT) {\n                        IAllowanceTransfer.PermitSingle calldata permitSingle;\n                        assembly {\n                            permitSingle := inputs.offset\n                        }\n                        bytes calldata data = inputs.toBytes(6); \n                        PERMIT2.permit(lockedBy, permitSingle, data);\n                    } else if (command == Commands.WRAP_ETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.wrapETH(map(recipient), amountMin);\n                    } else if (command == Commands.UNWRAP_WETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.unwrapWETH9(map(recipient), amountMin);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM_BATCH) {\n                        (IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails) =\n                            abi.decode(inputs, (IAllowanceTransfer.AllowanceTransferDetails[]));\n                        permit2TransferFrom(batchDetails, lockedBy);\n                    } else if (command == Commands.BALANCE_CHECK_ERC20) {\n                        address owner;\n                        address token;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            minBalance := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC20(token).balanceOf(owner) >= minBalance);\n                        if (!success) output = abi.encodePacked(BalanceTooLow.selector);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            } else {\n                if (command < Commands.THIRD_IF_BOUNDARY) {\n                    if (command == Commands.SEAPORT_V1_5) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_5.call{value: value}(data);\n                    } else if (command == Commands.LOOKS_RARE_V2) {\n                        uint256 value;\n                        assembly {\n                            value := calldataload(inputs.offset)\n                        }\n                        bytes calldata data = inputs.toBytes(1);\n                        (success, output) = LOOKS_RARE_V2.call{value: value}(data);\n                    } else if (command == Commands.NFTX) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = NFTX_ZAP.call{value: value}(data);\n                    } else if (command == Commands.CRYPTOPUNKS) {\n                        uint256 punkId;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            punkId := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        (success, output) = CRYPTOPUNKS.call{value: value}(\n                            abi.encodeWithSelector(ICryptoPunksMarket.buyPunk.selector, punkId)\n                        );\n                        if (success) ICryptoPunksMarket(CRYPTOPUNKS).transferPunk(map(recipient), punkId);\n                        else output = abi.encodePacked(BuyPunkFailed.selector);\n                    } else if (command == Commands.OWNER_CHECK_721) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC721(token).ownerOf(id) == owner);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC721.selector);\n                    } else if (command == Commands.OWNER_CHECK_1155) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            minBalance := calldataload(add(inputs.offset, 0x60))\n                        }\n                        success = (ERC1155(token).balanceOf(owner, id) >= minBalance);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC1155.selector);\n                    } else if (command == Commands.SWEEP_ERC721) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweepERC721(token, map(recipient), id);\n                    }\n                } else {\n                    if (command == Commands.X2Y2_721) {\n                        (success, output) = callAndTransfer721(inputs, X2Y2);\n                    } else if (command == Commands.SUDOSWAP) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SUDOSWAP.call{value: value}(data);\n                    } else if (command == Commands.NFT20) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = NFT20_ZAP.call{value: value}(data);\n                    } else if (command == Commands.X2Y2_1155) {\n                        (success, output) = callAndTransfer1155(inputs, X2Y2);\n                    } else if (command == Commands.FOUNDATION) {\n                        (success, output) = callAndTransfer721(inputs, FOUNDATION);\n                    } else if (command == Commands.SWEEP_ERC1155) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        uint256 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            amount := calldataload(add(inputs.offset, 0x60))\n                        }\n                        Payments.sweepERC1155(token, map(recipient), id, amount);\n                    } else if (command == Commands.ELEMENT_MARKET) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = ELEMENT_MARKET.call{value: value}(data);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            }\n        } else {\n            if (command == Commands.SEAPORT_V1_4) {\n                (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                (success, output) = SEAPORT_V1_4.call{value: value}(data);\n            } else if (command == Commands.EXECUTE_SUB_PLAN) {\n                bytes calldata _commands = inputs.toBytes(0);\n                bytes[] calldata _inputs = inputs.toBytesArray(1);\n                (success, output) =\n                    (address(this)).call(abi.encodeWithSelector(Dispatcher.execute.selector, _commands, _inputs));\n            } else if (command == Commands.APPROVE_ERC20) {\n                ERC20 token;\n                RouterImmutables.Spenders spender;\n                assembly {\n                    token := calldataload(inputs.offset)\n                    spender := calldataload(add(inputs.offset, 0x20))\n                }\n                Payments.approveERC20(token, spender);\n            } else {\n                revert InvalidCommandType(command);\n            }\n        }\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) external payable virtual;\n    function callAndTransfer721(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC721(token).safeTransferFrom(address(this), map(recipient), id);\n    }\n    function callAndTransfer1155(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        uint256 amount;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n            amount := calldataload(add(inputs.offset, 0xa0))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC1155(token).safeTransferFrom(address(this), map(recipient), id, amount, new bytes(0));\n    }\n    function getValueAndData(bytes calldata inputs) internal pure returns (uint256 value, bytes calldata data) {\n        assembly {\n            value := calldataload(inputs.offset)\n        }\n        data = inputs.toBytes(1);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Dispatcher.execute', 'start_line': 1886, 'end_line': 1886, 'offset_start': 78839, 'offset_end': 78930, 'content': 'function execute(bytes calldata commands, bytes[] calldata inputs) external payable virtual;', 'contract_name': 'Dispatcher', 'contract_code': '{\n    using BytesLib for bytes;\n    error InvalidCommandType(uint256 commandType);\n    error BuyPunkFailed();\n    error InvalidOwnerERC721();\n    error InvalidOwnerERC1155();\n    error BalanceTooLow();\n    function dispatch(bytes1 commandType, bytes calldata inputs) internal returns (bool success, bytes memory output) {\n        uint256 command = uint8(commandType & Commands.COMMAND_TYPE_MASK);\n        success = true;\n        if (command < Commands.FOURTH_IF_BOUNDARY) {\n            if (command < Commands.SECOND_IF_BOUNDARY) {\n                if (command < Commands.FIRST_IF_BOUNDARY) {\n                    if (command == Commands.V3_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V3_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM) {\n                        address token;\n                        address recipient;\n                        uint160 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amount := calldataload(add(inputs.offset, 0x40))\n                        }\n                        permit2TransferFrom(token, lockedBy, map(recipient), amount);\n                    } else if (command == Commands.PERMIT2_PERMIT_BATCH) {\n                        (IAllowanceTransfer.PermitBatch memory permitBatch,) =\n                            abi.decode(inputs, (IAllowanceTransfer.PermitBatch, bytes));\n                        bytes calldata data = inputs.toBytes(1);\n                        PERMIT2.permit(lockedBy, permitBatch, data);\n                    } else if (command == Commands.SWEEP) {\n                        address token;\n                        address recipient;\n                        uint160 amountMin;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amountMin := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweep(token, map(recipient), amountMin);\n                    } else if (command == Commands.TRANSFER) {\n                        address token;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.pay(token, map(recipient), value);\n                    } else if (command == Commands.PAY_PORTION) {\n                        address token;\n                        address recipient;\n                        uint256 bips;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            bips := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.payPortion(token, map(recipient), bips);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.V2_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V2_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_PERMIT) {\n                        IAllowanceTransfer.PermitSingle calldata permitSingle;\n                        assembly {\n                            permitSingle := inputs.offset\n                        }\n                        bytes calldata data = inputs.toBytes(6); \n                        PERMIT2.permit(lockedBy, permitSingle, data);\n                    } else if (command == Commands.WRAP_ETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.wrapETH(map(recipient), amountMin);\n                    } else if (command == Commands.UNWRAP_WETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.unwrapWETH9(map(recipient), amountMin);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM_BATCH) {\n                        (IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails) =\n                            abi.decode(inputs, (IAllowanceTransfer.AllowanceTransferDetails[]));\n                        permit2TransferFrom(batchDetails, lockedBy);\n                    } else if (command == Commands.BALANCE_CHECK_ERC20) {\n                        address owner;\n                        address token;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            minBalance := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC20(token).balanceOf(owner) >= minBalance);\n                        if (!success) output = abi.encodePacked(BalanceTooLow.selector);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            } else {\n                if (command < Commands.THIRD_IF_BOUNDARY) {\n                    if (command == Commands.SEAPORT_V1_5) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_5.call{value: value}(data);\n                    } else if (command == Commands.LOOKS_RARE_V2) {\n                        uint256 value;\n                        assembly {\n                            value := calldataload(inputs.offset)\n                        }\n                        bytes calldata data = inputs.toBytes(1);\n                        (success, output) = LOOKS_RARE_V2.call{value: value}(data);\n                    } else if (command == Commands.NFTX) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = NFTX_ZAP.call{value: value}(data);\n                    } else if (command == Commands.CRYPTOPUNKS) {\n                        uint256 punkId;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            punkId := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        (success, output) = CRYPTOPUNKS.call{value: value}(\n                            abi.encodeWithSelector(ICryptoPunksMarket.buyPunk.selector, punkId)\n                        );\n                        if (success) ICryptoPunksMarket(CRYPTOPUNKS).transferPunk(map(recipient), punkId);\n                        else output = abi.encodePacked(BuyPunkFailed.selector);\n                    } else if (command == Commands.OWNER_CHECK_721) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC721(token).ownerOf(id) == owner);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC721.selector);\n                    } else if (command == Commands.OWNER_CHECK_1155) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            minBalance := calldataload(add(inputs.offset, 0x60))\n                        }\n                        success = (ERC1155(token).balanceOf(owner, id) >= minBalance);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC1155.selector);\n                    } else if (command == Commands.SWEEP_ERC721) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweepERC721(token, map(recipient), id);\n                    }\n                } else {\n                    if (command == Commands.X2Y2_721) {\n                        (success, output) = callAndTransfer721(inputs, X2Y2);\n                    } else if (command == Commands.SUDOSWAP) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SUDOSWAP.call{value: value}(data);\n                    } else if (command == Commands.NFT20) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = NFT20_ZAP.call{value: value}(data);\n                    } else if (command == Commands.X2Y2_1155) {\n                        (success, output) = callAndTransfer1155(inputs, X2Y2);\n                    } else if (command == Commands.FOUNDATION) {\n                        (success, output) = callAndTransfer721(inputs, FOUNDATION);\n                    } else if (command == Commands.SWEEP_ERC1155) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        uint256 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            amount := calldataload(add(inputs.offset, 0x60))\n                        }\n                        Payments.sweepERC1155(token, map(recipient), id, amount);\n                    } else if (command == Commands.ELEMENT_MARKET) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = ELEMENT_MARKET.call{value: value}(data);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            }\n        } else {\n            if (command == Commands.SEAPORT_V1_4) {\n                (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                (success, output) = SEAPORT_V1_4.call{value: value}(data);\n            } else if (command == Commands.EXECUTE_SUB_PLAN) {\n                bytes calldata _commands = inputs.toBytes(0);\n                bytes[] calldata _inputs = inputs.toBytesArray(1);\n                (success, output) =\n                    (address(this)).call(abi.encodeWithSelector(Dispatcher.execute.selector, _commands, _inputs));\n            } else if (command == Commands.APPROVE_ERC20) {\n                ERC20 token;\n                RouterImmutables.Spenders spender;\n                assembly {\n                    token := calldataload(inputs.offset)\n                    spender := calldataload(add(inputs.offset, 0x20))\n                }\n                Payments.approveERC20(token, spender);\n            } else {\n                revert InvalidCommandType(command);\n            }\n        }\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) external payable virtual;\n    function callAndTransfer721(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC721(token).safeTransferFrom(address(this), map(recipient), id);\n    }\n    function callAndTransfer1155(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        uint256 amount;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n            amount := calldataload(add(inputs.offset, 0xa0))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC1155(token).safeTransferFrom(address(this), map(recipient), id, amount, new bytes(0));\n    }\n    function getValueAndData(bytes calldata inputs) internal pure returns (uint256 value, bytes calldata data) {\n        assembly {\n            value := calldataload(inputs.offset)\n        }\n        data = inputs.toBytes(1);\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Dispatcher.callAndTransfer721', 'start_line': 1887, 'end_line': 1902, 'offset_start': 78936, 'offset_end': 79587, 'content': 'function callAndTransfer721(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC721(token).safeTransferFrom(address(this), map(recipient), id);\n    }', 'contract_name': 'Dispatcher', 'contract_code': '{\n    using BytesLib for bytes;\n    error InvalidCommandType(uint256 commandType);\n    error BuyPunkFailed();\n    error InvalidOwnerERC721();\n    error InvalidOwnerERC1155();\n    error BalanceTooLow();\n    function dispatch(bytes1 commandType, bytes calldata inputs) internal returns (bool success, bytes memory output) {\n        uint256 command = uint8(commandType & Commands.COMMAND_TYPE_MASK);\n        success = true;\n        if (command < Commands.FOURTH_IF_BOUNDARY) {\n            if (command < Commands.SECOND_IF_BOUNDARY) {\n                if (command < Commands.FIRST_IF_BOUNDARY) {\n                    if (command == Commands.V3_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V3_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM) {\n                        address token;\n                        address recipient;\n                        uint160 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amount := calldataload(add(inputs.offset, 0x40))\n                        }\n                        permit2TransferFrom(token, lockedBy, map(recipient), amount);\n                    } else if (command == Commands.PERMIT2_PERMIT_BATCH) {\n                        (IAllowanceTransfer.PermitBatch memory permitBatch,) =\n                            abi.decode(inputs, (IAllowanceTransfer.PermitBatch, bytes));\n                        bytes calldata data = inputs.toBytes(1);\n                        PERMIT2.permit(lockedBy, permitBatch, data);\n                    } else if (command == Commands.SWEEP) {\n                        address token;\n                        address recipient;\n                        uint160 amountMin;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amountMin := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweep(token, map(recipient), amountMin);\n                    } else if (command == Commands.TRANSFER) {\n                        address token;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.pay(token, map(recipient), value);\n                    } else if (command == Commands.PAY_PORTION) {\n                        address token;\n                        address recipient;\n                        uint256 bips;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            bips := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.payPortion(token, map(recipient), bips);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.V2_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V2_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_PERMIT) {\n                        IAllowanceTransfer.PermitSingle calldata permitSingle;\n                        assembly {\n                            permitSingle := inputs.offset\n                        }\n                        bytes calldata data = inputs.toBytes(6); \n                        PERMIT2.permit(lockedBy, permitSingle, data);\n                    } else if (command == Commands.WRAP_ETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.wrapETH(map(recipient), amountMin);\n                    } else if (command == Commands.UNWRAP_WETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.unwrapWETH9(map(recipient), amountMin);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM_BATCH) {\n                        (IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails) =\n                            abi.decode(inputs, (IAllowanceTransfer.AllowanceTransferDetails[]));\n                        permit2TransferFrom(batchDetails, lockedBy);\n                    } else if (command == Commands.BALANCE_CHECK_ERC20) {\n                        address owner;\n                        address token;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            minBalance := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC20(token).balanceOf(owner) >= minBalance);\n                        if (!success) output = abi.encodePacked(BalanceTooLow.selector);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            } else {\n                if (command < Commands.THIRD_IF_BOUNDARY) {\n                    if (command == Commands.SEAPORT_V1_5) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_5.call{value: value}(data);\n                    } else if (command == Commands.LOOKS_RARE_V2) {\n                        uint256 value;\n                        assembly {\n                            value := calldataload(inputs.offset)\n                        }\n                        bytes calldata data = inputs.toBytes(1);\n                        (success, output) = LOOKS_RARE_V2.call{value: value}(data);\n                    } else if (command == Commands.NFTX) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = NFTX_ZAP.call{value: value}(data);\n                    } else if (command == Commands.CRYPTOPUNKS) {\n                        uint256 punkId;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            punkId := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        (success, output) = CRYPTOPUNKS.call{value: value}(\n                            abi.encodeWithSelector(ICryptoPunksMarket.buyPunk.selector, punkId)\n                        );\n                        if (success) ICryptoPunksMarket(CRYPTOPUNKS).transferPunk(map(recipient), punkId);\n                        else output = abi.encodePacked(BuyPunkFailed.selector);\n                    } else if (command == Commands.OWNER_CHECK_721) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC721(token).ownerOf(id) == owner);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC721.selector);\n                    } else if (command == Commands.OWNER_CHECK_1155) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            minBalance := calldataload(add(inputs.offset, 0x60))\n                        }\n                        success = (ERC1155(token).balanceOf(owner, id) >= minBalance);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC1155.selector);\n                    } else if (command == Commands.SWEEP_ERC721) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweepERC721(token, map(recipient), id);\n                    }\n                } else {\n                    if (command == Commands.X2Y2_721) {\n                        (success, output) = callAndTransfer721(inputs, X2Y2);\n                    } else if (command == Commands.SUDOSWAP) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SUDOSWAP.call{value: value}(data);\n                    } else if (command == Commands.NFT20) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = NFT20_ZAP.call{value: value}(data);\n                    } else if (command == Commands.X2Y2_1155) {\n                        (success, output) = callAndTransfer1155(inputs, X2Y2);\n                    } else if (command == Commands.FOUNDATION) {\n                        (success, output) = callAndTransfer721(inputs, FOUNDATION);\n                    } else if (command == Commands.SWEEP_ERC1155) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        uint256 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            amount := calldataload(add(inputs.offset, 0x60))\n                        }\n                        Payments.sweepERC1155(token, map(recipient), id, amount);\n                    } else if (command == Commands.ELEMENT_MARKET) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = ELEMENT_MARKET.call{value: value}(data);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            }\n        } else {\n            if (command == Commands.SEAPORT_V1_4) {\n                (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                (success, output) = SEAPORT_V1_4.call{value: value}(data);\n            } else if (command == Commands.EXECUTE_SUB_PLAN) {\n                bytes calldata _commands = inputs.toBytes(0);\n                bytes[] calldata _inputs = inputs.toBytesArray(1);\n                (success, output) =\n                    (address(this)).call(abi.encodeWithSelector(Dispatcher.execute.selector, _commands, _inputs));\n            } else if (command == Commands.APPROVE_ERC20) {\n                ERC20 token;\n                RouterImmutables.Spenders spender;\n                assembly {\n                    token := calldataload(inputs.offset)\n                    spender := calldataload(add(inputs.offset, 0x20))\n                }\n                Payments.approveERC20(token, spender);\n            } else {\n                revert InvalidCommandType(command);\n            }\n        }\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) external payable virtual;\n    function callAndTransfer721(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC721(token).safeTransferFrom(address(this), map(recipient), id);\n    }\n    function callAndTransfer1155(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        uint256 amount;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n            amount := calldataload(add(inputs.offset, 0xa0))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC1155(token).safeTransferFrom(address(this), map(recipient), id, amount, new bytes(0));\n    }\n    function getValueAndData(bytes calldata inputs) internal pure returns (uint256 value, bytes calldata data) {\n        assembly {\n            value := calldataload(inputs.offset)\n        }\n        data = inputs.toBytes(1);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Dispatcher.callAndTransfer1155', 'start_line': 1903, 'end_line': 1920, 'offset_start': 79593, 'offset_end': 80353, 'content': 'function callAndTransfer1155(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        uint256 amount;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n            amount := calldataload(add(inputs.offset, 0xa0))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC1155(token).safeTransferFrom(address(this), map(recipient), id, amount, new bytes(0));\n    }', 'contract_name': 'Dispatcher', 'contract_code': '{\n    using BytesLib for bytes;\n    error InvalidCommandType(uint256 commandType);\n    error BuyPunkFailed();\n    error InvalidOwnerERC721();\n    error InvalidOwnerERC1155();\n    error BalanceTooLow();\n    function dispatch(bytes1 commandType, bytes calldata inputs) internal returns (bool success, bytes memory output) {\n        uint256 command = uint8(commandType & Commands.COMMAND_TYPE_MASK);\n        success = true;\n        if (command < Commands.FOURTH_IF_BOUNDARY) {\n            if (command < Commands.SECOND_IF_BOUNDARY) {\n                if (command < Commands.FIRST_IF_BOUNDARY) {\n                    if (command == Commands.V3_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V3_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM) {\n                        address token;\n                        address recipient;\n                        uint160 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amount := calldataload(add(inputs.offset, 0x40))\n                        }\n                        permit2TransferFrom(token, lockedBy, map(recipient), amount);\n                    } else if (command == Commands.PERMIT2_PERMIT_BATCH) {\n                        (IAllowanceTransfer.PermitBatch memory permitBatch,) =\n                            abi.decode(inputs, (IAllowanceTransfer.PermitBatch, bytes));\n                        bytes calldata data = inputs.toBytes(1);\n                        PERMIT2.permit(lockedBy, permitBatch, data);\n                    } else if (command == Commands.SWEEP) {\n                        address token;\n                        address recipient;\n                        uint160 amountMin;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amountMin := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweep(token, map(recipient), amountMin);\n                    } else if (command == Commands.TRANSFER) {\n                        address token;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.pay(token, map(recipient), value);\n                    } else if (command == Commands.PAY_PORTION) {\n                        address token;\n                        address recipient;\n                        uint256 bips;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            bips := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.payPortion(token, map(recipient), bips);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.V2_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V2_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_PERMIT) {\n                        IAllowanceTransfer.PermitSingle calldata permitSingle;\n                        assembly {\n                            permitSingle := inputs.offset\n                        }\n                        bytes calldata data = inputs.toBytes(6); \n                        PERMIT2.permit(lockedBy, permitSingle, data);\n                    } else if (command == Commands.WRAP_ETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.wrapETH(map(recipient), amountMin);\n                    } else if (command == Commands.UNWRAP_WETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.unwrapWETH9(map(recipient), amountMin);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM_BATCH) {\n                        (IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails) =\n                            abi.decode(inputs, (IAllowanceTransfer.AllowanceTransferDetails[]));\n                        permit2TransferFrom(batchDetails, lockedBy);\n                    } else if (command == Commands.BALANCE_CHECK_ERC20) {\n                        address owner;\n                        address token;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            minBalance := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC20(token).balanceOf(owner) >= minBalance);\n                        if (!success) output = abi.encodePacked(BalanceTooLow.selector);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            } else {\n                if (command < Commands.THIRD_IF_BOUNDARY) {\n                    if (command == Commands.SEAPORT_V1_5) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_5.call{value: value}(data);\n                    } else if (command == Commands.LOOKS_RARE_V2) {\n                        uint256 value;\n                        assembly {\n                            value := calldataload(inputs.offset)\n                        }\n                        bytes calldata data = inputs.toBytes(1);\n                        (success, output) = LOOKS_RARE_V2.call{value: value}(data);\n                    } else if (command == Commands.NFTX) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = NFTX_ZAP.call{value: value}(data);\n                    } else if (command == Commands.CRYPTOPUNKS) {\n                        uint256 punkId;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            punkId := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        (success, output) = CRYPTOPUNKS.call{value: value}(\n                            abi.encodeWithSelector(ICryptoPunksMarket.buyPunk.selector, punkId)\n                        );\n                        if (success) ICryptoPunksMarket(CRYPTOPUNKS).transferPunk(map(recipient), punkId);\n                        else output = abi.encodePacked(BuyPunkFailed.selector);\n                    } else if (command == Commands.OWNER_CHECK_721) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC721(token).ownerOf(id) == owner);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC721.selector);\n                    } else if (command == Commands.OWNER_CHECK_1155) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            minBalance := calldataload(add(inputs.offset, 0x60))\n                        }\n                        success = (ERC1155(token).balanceOf(owner, id) >= minBalance);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC1155.selector);\n                    } else if (command == Commands.SWEEP_ERC721) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweepERC721(token, map(recipient), id);\n                    }\n                } else {\n                    if (command == Commands.X2Y2_721) {\n                        (success, output) = callAndTransfer721(inputs, X2Y2);\n                    } else if (command == Commands.SUDOSWAP) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SUDOSWAP.call{value: value}(data);\n                    } else if (command == Commands.NFT20) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = NFT20_ZAP.call{value: value}(data);\n                    } else if (command == Commands.X2Y2_1155) {\n                        (success, output) = callAndTransfer1155(inputs, X2Y2);\n                    } else if (command == Commands.FOUNDATION) {\n                        (success, output) = callAndTransfer721(inputs, FOUNDATION);\n                    } else if (command == Commands.SWEEP_ERC1155) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        uint256 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            amount := calldataload(add(inputs.offset, 0x60))\n                        }\n                        Payments.sweepERC1155(token, map(recipient), id, amount);\n                    } else if (command == Commands.ELEMENT_MARKET) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = ELEMENT_MARKET.call{value: value}(data);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            }\n        } else {\n            if (command == Commands.SEAPORT_V1_4) {\n                (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                (success, output) = SEAPORT_V1_4.call{value: value}(data);\n            } else if (command == Commands.EXECUTE_SUB_PLAN) {\n                bytes calldata _commands = inputs.toBytes(0);\n                bytes[] calldata _inputs = inputs.toBytesArray(1);\n                (success, output) =\n                    (address(this)).call(abi.encodeWithSelector(Dispatcher.execute.selector, _commands, _inputs));\n            } else if (command == Commands.APPROVE_ERC20) {\n                ERC20 token;\n                RouterImmutables.Spenders spender;\n                assembly {\n                    token := calldataload(inputs.offset)\n                    spender := calldataload(add(inputs.offset, 0x20))\n                }\n                Payments.approveERC20(token, spender);\n            } else {\n                revert InvalidCommandType(command);\n            }\n        }\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) external payable virtual;\n    function callAndTransfer721(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC721(token).safeTransferFrom(address(this), map(recipient), id);\n    }\n    function callAndTransfer1155(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        uint256 amount;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n            amount := calldataload(add(inputs.offset, 0xa0))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC1155(token).safeTransferFrom(address(this), map(recipient), id, amount, new bytes(0));\n    }\n    function getValueAndData(bytes calldata inputs) internal pure returns (uint256 value, bytes calldata data) {\n        assembly {\n            value := calldataload(inputs.offset)\n        }\n        data = inputs.toBytes(1);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'Dispatcher.getValueAndData', 'start_line': 1921, 'end_line': 1926, 'offset_start': 80359, 'offset_end': 80584, 'content': 'function getValueAndData(bytes calldata inputs) internal pure returns (uint256 value, bytes calldata data) {\n        assembly {\n            value := calldataload(inputs.offset)\n        }\n        data = inputs.toBytes(1);\n    }', 'contract_name': 'Dispatcher', 'contract_code': '{\n    using BytesLib for bytes;\n    error InvalidCommandType(uint256 commandType);\n    error BuyPunkFailed();\n    error InvalidOwnerERC721();\n    error InvalidOwnerERC1155();\n    error BalanceTooLow();\n    function dispatch(bytes1 commandType, bytes calldata inputs) internal returns (bool success, bytes memory output) {\n        uint256 command = uint8(commandType & Commands.COMMAND_TYPE_MASK);\n        success = true;\n        if (command < Commands.FOURTH_IF_BOUNDARY) {\n            if (command < Commands.SECOND_IF_BOUNDARY) {\n                if (command < Commands.FIRST_IF_BOUNDARY) {\n                    if (command == Commands.V3_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V3_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM) {\n                        address token;\n                        address recipient;\n                        uint160 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amount := calldataload(add(inputs.offset, 0x40))\n                        }\n                        permit2TransferFrom(token, lockedBy, map(recipient), amount);\n                    } else if (command == Commands.PERMIT2_PERMIT_BATCH) {\n                        (IAllowanceTransfer.PermitBatch memory permitBatch,) =\n                            abi.decode(inputs, (IAllowanceTransfer.PermitBatch, bytes));\n                        bytes calldata data = inputs.toBytes(1);\n                        PERMIT2.permit(lockedBy, permitBatch, data);\n                    } else if (command == Commands.SWEEP) {\n                        address token;\n                        address recipient;\n                        uint160 amountMin;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amountMin := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweep(token, map(recipient), amountMin);\n                    } else if (command == Commands.TRANSFER) {\n                        address token;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.pay(token, map(recipient), value);\n                    } else if (command == Commands.PAY_PORTION) {\n                        address token;\n                        address recipient;\n                        uint256 bips;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            bips := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.payPortion(token, map(recipient), bips);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.V2_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V2_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_PERMIT) {\n                        IAllowanceTransfer.PermitSingle calldata permitSingle;\n                        assembly {\n                            permitSingle := inputs.offset\n                        }\n                        bytes calldata data = inputs.toBytes(6); \n                        PERMIT2.permit(lockedBy, permitSingle, data);\n                    } else if (command == Commands.WRAP_ETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.wrapETH(map(recipient), amountMin);\n                    } else if (command == Commands.UNWRAP_WETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.unwrapWETH9(map(recipient), amountMin);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM_BATCH) {\n                        (IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails) =\n                            abi.decode(inputs, (IAllowanceTransfer.AllowanceTransferDetails[]));\n                        permit2TransferFrom(batchDetails, lockedBy);\n                    } else if (command == Commands.BALANCE_CHECK_ERC20) {\n                        address owner;\n                        address token;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            minBalance := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC20(token).balanceOf(owner) >= minBalance);\n                        if (!success) output = abi.encodePacked(BalanceTooLow.selector);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            } else {\n                if (command < Commands.THIRD_IF_BOUNDARY) {\n                    if (command == Commands.SEAPORT_V1_5) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_5.call{value: value}(data);\n                    } else if (command == Commands.LOOKS_RARE_V2) {\n                        uint256 value;\n                        assembly {\n                            value := calldataload(inputs.offset)\n                        }\n                        bytes calldata data = inputs.toBytes(1);\n                        (success, output) = LOOKS_RARE_V2.call{value: value}(data);\n                    } else if (command == Commands.NFTX) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = NFTX_ZAP.call{value: value}(data);\n                    } else if (command == Commands.CRYPTOPUNKS) {\n                        uint256 punkId;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            punkId := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        (success, output) = CRYPTOPUNKS.call{value: value}(\n                            abi.encodeWithSelector(ICryptoPunksMarket.buyPunk.selector, punkId)\n                        );\n                        if (success) ICryptoPunksMarket(CRYPTOPUNKS).transferPunk(map(recipient), punkId);\n                        else output = abi.encodePacked(BuyPunkFailed.selector);\n                    } else if (command == Commands.OWNER_CHECK_721) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC721(token).ownerOf(id) == owner);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC721.selector);\n                    } else if (command == Commands.OWNER_CHECK_1155) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            minBalance := calldataload(add(inputs.offset, 0x60))\n                        }\n                        success = (ERC1155(token).balanceOf(owner, id) >= minBalance);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC1155.selector);\n                    } else if (command == Commands.SWEEP_ERC721) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweepERC721(token, map(recipient), id);\n                    }\n                } else {\n                    if (command == Commands.X2Y2_721) {\n                        (success, output) = callAndTransfer721(inputs, X2Y2);\n                    } else if (command == Commands.SUDOSWAP) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SUDOSWAP.call{value: value}(data);\n                    } else if (command == Commands.NFT20) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = NFT20_ZAP.call{value: value}(data);\n                    } else if (command == Commands.X2Y2_1155) {\n                        (success, output) = callAndTransfer1155(inputs, X2Y2);\n                    } else if (command == Commands.FOUNDATION) {\n                        (success, output) = callAndTransfer721(inputs, FOUNDATION);\n                    } else if (command == Commands.SWEEP_ERC1155) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        uint256 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            amount := calldataload(add(inputs.offset, 0x60))\n                        }\n                        Payments.sweepERC1155(token, map(recipient), id, amount);\n                    } else if (command == Commands.ELEMENT_MARKET) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = ELEMENT_MARKET.call{value: value}(data);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            }\n        } else {\n            if (command == Commands.SEAPORT_V1_4) {\n                (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                (success, output) = SEAPORT_V1_4.call{value: value}(data);\n            } else if (command == Commands.EXECUTE_SUB_PLAN) {\n                bytes calldata _commands = inputs.toBytes(0);\n                bytes[] calldata _inputs = inputs.toBytesArray(1);\n                (success, output) =\n                    (address(this)).call(abi.encodeWithSelector(Dispatcher.execute.selector, _commands, _inputs));\n            } else if (command == Commands.APPROVE_ERC20) {\n                ERC20 token;\n                RouterImmutables.Spenders spender;\n                assembly {\n                    token := calldataload(inputs.offset)\n                    spender := calldataload(add(inputs.offset, 0x20))\n                }\n                Payments.approveERC20(token, spender);\n            } else {\n                revert InvalidCommandType(command);\n            }\n        }\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) external payable virtual;\n    function callAndTransfer721(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC721(token).safeTransferFrom(address(this), map(recipient), id);\n    }\n    function callAndTransfer1155(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        uint256 amount;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n            amount := calldataload(add(inputs.offset, 0xa0))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC1155(token).safeTransferFrom(address(this), map(recipient), id, amount, new bytes(0));\n    }\n    function getValueAndData(bytes calldata inputs) internal pure returns (uint256 value, bytes calldata data) {\n        assembly {\n            value := calldataload(inputs.offset)\n        }\n        data = inputs.toBytes(1);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH9.deposit', 'start_line': 1931, 'end_line': 1931, 'offset_start': 80716, 'offset_end': 80751, 'content': 'function deposit() external payable;', 'contract_name': 'IWETH9', 'contract_code': '{\n    function deposit() external payable;\n    function withdraw(uint256) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH9.withdraw', 'start_line': 1932, 'end_line': 1932, 'offset_start': 80757, 'offset_end': 80792, 'content': 'function withdraw(uint256) external;', 'contract_name': 'IWETH9', 'contract_code': '{\n    function deposit() external payable;\n    function withdraw(uint256) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ICryptoPunksMarket.buyPunk', 'start_line': 1936, 'end_line': 1936, 'offset_start': 80855, 'offset_end': 80907, 'content': 'function buyPunk(uint256 punkIndex) external payable;', 'contract_name': 'ICryptoPunksMarket', 'contract_code': '{\n    function buyPunk(uint256 punkIndex) external payable;\n    function transferPunk(address to, uint256 punkIndex) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
{'type': 'FunctionDefinition', 'name': 'ICryptoPunksMarket.transferPunk', 'start_line': 1937, 'end_line': 1937, 'offset_start': 80913, 'offset_end': 80974, 'content': 'function transferPunk(address to, uint256 punkIndex) external;', 'contract_name': 'ICryptoPunksMarket', 'contract_code': '{\n    function buyPunk(uint256 punkIndex) external payable;\n    function transferPunk(address to, uint256 punkIndex) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad/0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad.sol'}
