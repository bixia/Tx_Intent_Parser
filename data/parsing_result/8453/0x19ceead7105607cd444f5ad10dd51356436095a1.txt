{'type': 'FunctionDefinition', 'name': 'Context._msgSender', 'start_line': 4, 'end_line': 6, 'offset_start': 56, 'offset_end': 151, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgData', 'start_line': 7, 'end_line': 9, 'offset_start': 157, 'offset_end': 255, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.tor', 'start_line': 14, 'end_line': 16, 'offset_start': 419, 'offset_end': 481, 'content': 'constructor() {\n        _transferOwnership(_msgSender());\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.owner', 'start_line': 21, 'end_line': 23, 'offset_start': 554, 'offset_end': 638, 'content': 'function owner() public view virtual returns (address) {\n        return _owner;\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._checkOwner', 'start_line': 24, 'end_line': 26, 'offset_start': 644, 'offset_end': 773, 'content': 'function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.renounceOwnership', 'start_line': 27, 'end_line': 29, 'offset_start': 779, 'offset_end': 879, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.transferOwnership', 'start_line': 30, 'end_line': 33, 'offset_start': 885, 'offset_end': 1082, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._transferOwnership', 'start_line': 34, 'end_line': 38, 'offset_start': 1088, 'offset_end': 1274, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.permit', 'start_line': 41, 'end_line': 49, 'offset_start': 1307, 'offset_end': 1489, 'content': 'function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;', 'contract_name': 'IERC20Permit', 'contract_code': '{\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n    function nonces(address owner) external view returns (uint256);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.nonces', 'start_line': 50, 'end_line': 50, 'offset_start': 1495, 'offset_end': 1557, 'content': 'function nonces(address owner) external view returns (uint256);', 'contract_name': 'IERC20Permit', 'contract_code': '{\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n    function nonces(address owner) external view returns (uint256);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.DOMAIN_SEPARATOR', 'start_line': 51, 'end_line': 51, 'offset_start': 1563, 'offset_end': 1622, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IERC20Permit', 'contract_code': '{\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n    function nonces(address owner) external view returns (uint256);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.isContract', 'start_line': 54, 'end_line': 56, 'offset_start': 1648, 'offset_end': 1760, 'content': 'function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.sendValue', 'start_line': 57, 'end_line': 61, 'offset_start': 1766, 'offset_end': 2076, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 62, 'end_line': 64, 'offset_start': 2082, 'offset_end': 2266, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 65, 'end_line': 71, 'offset_start': 2272, 'offset_end': 2494, 'content': 'function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 72, 'end_line': 78, 'offset_start': 2500, 'offset_end': 2753, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 79, 'end_line': 88, 'offset_start': 2759, 'offset_end': 3204, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 89, 'end_line': 91, 'offset_start': 3210, 'offset_end': 3406, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 92, 'end_line': 99, 'offset_start': 3412, 'offset_end': 3737, 'content': 'function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 100, 'end_line': 102, 'offset_start': 3743, 'offset_end': 3940, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 103, 'end_line': 110, 'offset_start': 3946, 'offset_end': 4270, 'content': 'function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResultFromTarget', 'start_line': 111, 'end_line': 125, 'offset_start': 4276, 'offset_end': 4738, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResult', 'start_line': 126, 'end_line': 136, 'offset_start': 4744, 'offset_end': 5038, 'content': 'function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'Address._revert', 'start_line': 137, 'end_line': 146, 'offset_start': 5044, 'offset_end': 5386, 'content': 'function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransfer', 'start_line': 150, 'end_line': 156, 'offset_start': 5445, 'offset_end': 5649, 'content': 'function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransferFrom', 'start_line': 157, 'end_line': 164, 'offset_start': 5655, 'offset_end': 5895, 'content': 'function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeApprove', 'start_line': 165, 'end_line': 175, 'offset_start': 5901, 'offset_end': 6286, 'content': 'function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeIncreaseAllowance', 'start_line': 176, 'end_line': 183, 'offset_start': 6292, 'offset_end': 6601, 'content': 'function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeDecreaseAllowance', 'start_line': 184, 'end_line': 195, 'offset_start': 6607, 'offset_end': 7092, 'content': 'function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safePermit', 'start_line': 196, 'end_line': 210, 'offset_start': 7098, 'offset_end': 7569, 'content': 'function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturn', 'start_line': 211, 'end_line': 216, 'offset_start': 7575, 'offset_end': 7902, 'content': 'function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 221, 'end_line': 221, 'offset_start': 8089, 'offset_end': 8143, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 222, 'end_line': 222, 'offset_start': 8149, 'offset_end': 8216, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 223, 'end_line': 223, 'offset_start': 8222, 'offset_end': 8291, 'content': 'function transfer(address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 224, 'end_line': 224, 'offset_start': 8297, 'offset_end': 8379, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 225, 'end_line': 225, 'offset_start': 8385, 'offset_end': 8458, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 226, 'end_line': 230, 'offset_start': 8464, 'offset_end': 8581, 'content': 'function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'ISignatureTransfer.permitTransferFrom', 'start_line': 251, 'end_line': 256, 'offset_start': 9053, 'offset_end': 9253, 'content': 'function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;', 'contract_name': 'ISignatureTransfer', 'contract_code': '{\n    struct TokenPermissions {\n        address token;\n        uint256 amount;\n    }\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        uint256 nonce;\n        uint256 deadline;\n    }\n    struct SignatureTransferDetails {\n        address to;\n        uint256 requestedAmount;\n    }\n    struct PermitBatchTransferFrom {\n        TokenPermissions[] permitted;\n        uint256 nonce;\n        uint256 deadline;\n    }\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'ISignatureTransfer.permitTransferFrom', 'start_line': 257, 'end_line': 262, 'offset_start': 9259, 'offset_end': 9466, 'content': 'function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;', 'contract_name': 'ISignatureTransfer', 'contract_code': '{\n    struct TokenPermissions {\n        address token;\n        uint256 amount;\n    }\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        uint256 nonce;\n        uint256 deadline;\n    }\n    struct SignatureTransferDetails {\n        address to;\n        uint256 requestedAmount;\n    }\n    struct PermitBatchTransferFrom {\n        TokenPermissions[] permitted;\n        uint256 nonce;\n        uint256 deadline;\n    }\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'IOdosExecutor.executePath', 'start_line': 265, 'end_line': 269, 'offset_start': 9498, 'offset_end': 9626, 'content': 'function executePath (\n    bytes calldata bytecode,\n    uint256[] memory inputAmount,\n    address msgSender\n  ) external payable;', 'contract_name': 'IOdosExecutor', 'contract_code': '{\n  function executePath (\n    bytes calldata bytecode,\n    uint256[] memory inputAmount,\n    address msgSender\n  ) external payable;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2.tor', 'start_line': 328, 'end_line': 333, 'offset_start': 11071, 'offset_end': 11242, 'content': 'constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2.', 'start_line': 334, 'end_line': 334, 'offset_start': 11246, 'offset_end': 11275, 'content': 'receive() external payable { }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2.swapCompact', 'start_line': 335, 'end_line': 403, 'offset_start': 11279, 'offset_end': 13655, 'content': 'function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2.swap', 'start_line': 404, 'end_line': 420, 'offset_start': 13659, 'offset_end': 13965, 'content': 'function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2._swapApproval', 'start_line': 421, 'end_line': 453, 'offset_start': 13969, 'offset_end': 14782, 'content': 'function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2.swapPermit2', 'start_line': 454, 'end_line': 486, 'offset_start': 14786, 'offset_end': 15573, 'content': 'function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2._swap', 'start_line': 487, 'end_line': 528, 'offset_start': 15577, 'offset_end': 17217, 'content': 'function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2.swapMultiCompact', 'start_line': 529, 'end_line': 618, 'offset_start': 17221, 'offset_end': 20369, 'content': 'function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2.swapMulti', 'start_line': 619, 'end_line': 639, 'offset_start': 20373, 'offset_end': 20793, 'content': 'function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2._swapMultiApproval', 'start_line': 640, 'end_line': 679, 'offset_start': 20797, 'offset_end': 21860, 'content': 'function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2.swapMultiPermit2', 'start_line': 680, 'end_line': 741, 'offset_start': 21864, 'offset_end': 23881, 'content': 'function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2._swapMulti', 'start_line': 742, 'end_line': 825, 'offset_start': 23885, 'offset_end': 26792, 'content': 'function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2.registerReferralCode', 'start_line': 826, 'end_line': 844, 'offset_start': 26796, 'offset_end': 27488, 'content': 'function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2.setSwapMultiFee', 'start_line': 845, 'end_line': 853, 'offset_start': 27492, 'offset_end': 27679, 'content': 'function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2.writeAddressList', 'start_line': 854, 'end_line': 863, 'offset_start': 27683, 'offset_end': 27878, 'content': 'function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2.transferRouterFunds', 'start_line': 864, 'end_line': 880, 'offset_start': 27882, 'offset_end': 28295, 'content': 'function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2.swapRouterFunds', 'start_line': 881, 'end_line': 931, 'offset_start': 28299, 'offset_end': 29950, 'content': 'function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2._universalBalance', 'start_line': 932, 'end_line': 938, 'offset_start': 29954, 'offset_end': 30163, 'content': 'function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
{'type': 'FunctionDefinition', 'name': 'OdosRouterV2._universalTransfer', 'start_line': 939, 'end_line': 946, 'offset_start': 30167, 'offset_end': 30448, 'content': 'function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }', 'contract_name': 'OdosRouterV2', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  address constant _ETH = address(0);\n  uint256 private constant addressListStart = \n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\n  address[] public addressList;\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\n  uint256 public constant FEE_DENOM = 1e18;\n  uint256 public swapMultiFee;\n  struct permit2Info {\n    address contractAddress;\n    uint256 nonce;\n    uint256 deadline;\n    bytes signature;\n  }\n  struct swapTokenInfo {\n    address inputToken;\n    uint256 inputAmount;\n    address inputReceiver;\n    address outputToken;\n    uint256 outputQuote;\n    uint256 outputMin;\n    address outputReceiver;\n  }\n  struct inputTokenInfo {\n    address tokenAddress;\n    uint256 amountIn;\n    address receiver;\n  }\n  struct outputTokenInfo {\n    address tokenAddress;\n    uint256 relativeValue;\n    address receiver;\n  }\n  event Swap(\n    address sender,\n    uint256 inputAmount,\n    address inputToken,\n    uint256 amountOut,\n    address outputToken,\n    int256 slippage,\n    uint32 referralCode\n  );\n  event SwapMulti(\n    address sender,\n    uint256[] amountsIn,\n    address[] tokensIn,\n    uint256[] amountsOut,\n    address[] tokensOut,\n    uint32 referralCode\n  );\n  struct referralInfo {\n    uint64 referralFee;\n    address beneficiary;\n    bool registered;\n  }\n  mapping(uint32 => referralInfo) public referralLookup;\n  constructor() {\n    referralLookup[0].referralFee = 0;\n    referralLookup[0].beneficiary = address(0);\n    referralLookup[0].registered = true;\n    swapMultiFee = 5e14;\n  }\n  receive() external payable { }\n  function swapCompact() \n    external\n    payable\n    returns (uint256)\n  {\n    swapTokenInfo memory tokenInfo;\n    address executor;\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    {\n      address msgSender = msg.sender;\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        let result := 0\n        let pos := 4\n        result, pos := getAddress(pos)\n        mstore(tokenInfo, result)\n        result, pos := getAddress(pos)\n        mstore(add(tokenInfo, 0x60), result)\n        let inputAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        if inputAmountLength {\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, inputAmountLength)\n        }\n        let quoteAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\n        mstore(add(tokenInfo, 0x80), outputQuote)\n        pos := add(pos, quoteAmountLength)\n        {\n          let slippageTolerance := shr(232, calldataload(pos))\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\n        }\n        pos := add(pos, 3)\n        executor, pos := getAddress(pos)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := executor }\n        mstore(add(tokenInfo, 0x40), result)\n        result, pos := getAddress(pos)\n        if eq(result, 0) { result := msgSender }\n        mstore(add(tokenInfo, 0xC0), result)\n        referralCode := shr(224, calldataload(pos))\n        pos := add(pos, 4)\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n        pathDefinition.offset := add(pos, 1)\n      }\n    }\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256 amountOut)\n  {\n    return _swapApproval(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapApproval(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    if (tokenInfo.inputToken == _ETH) {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = msg.value;\n      } else {\n        require(msg.value == tokenInfo.inputAmount, "Wrong msg.value");\n      }\n    }\n    else {\n      if (tokenInfo.inputAmount == 0) {\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\n      }\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\n        msg.sender,\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      );\n    }\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapPermit2(\n    permit2Info memory permit2,\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    returns (uint256 amountOut)\n  {\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(\n          tokenInfo.inputToken,\n          tokenInfo.inputAmount\n        ),\n        permit2.nonce,\n        permit2.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(\n        tokenInfo.inputReceiver,\n        tokenInfo.inputAmount\n      ),\n      msg.sender,\n      permit2.signature\n    );\n    return _swap(\n      tokenInfo,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swap(\n    swapTokenInfo memory tokenInfo,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256 amountOut)\n  {\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, "Minimum greater than quote");\n    require(tokenInfo.outputMin > 0, "Slippage limit too low");\n    require(tokenInfo.inputToken != tokenInfo.outputToken, "Arbitrage not supported");\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\n    uint256[] memory amountsIn = new uint256[](1);\n    amountsIn[0] = tokenInfo.inputAmount;\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\n      _universalTransfer(\n        tokenInfo.outputToken,\n        thisReferralInfo.beneficiary,\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n      );\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n    }\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\n    if (slippage > 0) {\n      amountOut = tokenInfo.outputQuote;\n    }\n    require(amountOut >= tokenInfo.outputMin, "Slippage Limit Exceeded");\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\n    emit Swap(\n      msg.sender,\n      tokenInfo.inputAmount,\n      tokenInfo.inputToken,\n      amountOut,\n      tokenInfo.outputToken,\n      slippage,\n      referralCode\n    );\n  }\n  function swapMultiCompact() \n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    address executor;\n    uint256 valueOutMin;\n    inputTokenInfo[] memory inputs;\n    outputTokenInfo[] memory outputs;\n    uint256 pos = 6;\n    {\n      address msgSender = msg.sender;\n      uint256 numInputs;\n      uint256 numOutputs;\n      assembly {\n        numInputs := shr(248, calldataload(4))\n        numOutputs := shr(248, calldataload(5))\n      }\n      inputs = new inputTokenInfo[](numInputs);\n      outputs = new outputTokenInfo[](numOutputs);\n      assembly {\n        function getAddress(currPos) -> result, newPos {\n          let inputPos := shr(240, calldataload(currPos))\n          switch inputPos\n          case 0x0000 {\n            newPos := add(currPos, 2)\n          }\n          case 0x0001 {\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            newPos := add(currPos, 22)\n          }\n          default {\n            result := sload(add(addressListStart, sub(inputPos, 2)))\n            newPos := add(currPos, 2)\n          }\n        }\n        executor, pos := getAddress(pos)\n        let outputMinAmountLength := shr(248, calldataload(pos))\n        pos := add(pos, 1)\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\n        pos := add(pos, outputMinAmountLength)\n        let result := 0\n        let memPos := 0\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let inputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          if inputAmountLength {\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\n            pos := add(pos, inputAmountLength)\n          }\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := executor }\n          mstore(add(memPos, 0x40), result)\n        }\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\n        {\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\n          result, pos := getAddress(pos)\n          mstore(memPos, result)\n          let outputAmountLength := shr(248, calldataload(pos))\n          pos := add(pos, 1)\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\n          pos := add(pos, outputAmountLength)\n          result, pos := getAddress(pos)\n          if eq(result, 0) { result := msgSender }\n          mstore(add(memPos, 0x40), result)\n        }\n      }\n    }\n    uint32 referralCode;\n    bytes calldata pathDefinition;\n    assembly {\n      referralCode := shr(224, calldataload(pos))\n      pos := add(pos, 4)\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\n      pathDefinition.offset := add(pos, 1)\n    }\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    return _swapMultiApproval(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMultiApproval(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    uint256 expected_msg_value = 0;\n    for (uint256 i = 0; i < inputs.length; i++) {\n      if (inputs[i].tokenAddress == _ETH) {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = msg.value;\n        }\n        expected_msg_value = inputs[i].amountIn;\n      } \n      else {\n        if (inputs[i].amountIn == 0) {\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n        }\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\n          msg.sender,\n          inputs[i].receiver,\n          inputs[i].amountIn\n        );\n      }\n    }\n    require(msg.value == expected_msg_value, "Wrong msg.value");\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function swapMultiPermit2(\n    permit2Info memory permit2,\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    external\n    payable\n    returns (uint256[] memory amountsOut)\n  {\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\n    {\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\n        new ISignatureTransfer.TokenPermissions[](permit_length),\n        permit2.nonce,\n        permit2.deadline\n      );\n      transferDetails = \n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\n    }\n    {\n      uint256 expected_msg_value = 0;\n      for (uint256 i = 0; i < inputs.length; i++) {\n        if (inputs[i].tokenAddress == _ETH) {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = msg.value;\n          }\n          expected_msg_value = inputs[i].amountIn;\n        }\n        else {\n          if (inputs[i].amountIn == 0) {\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\n          }\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\n          transferDetails[permit_index].to = inputs[i].receiver;\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\n        }\n      }\n      require(msg.value == expected_msg_value, "Wrong msg.value");\n    }\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\n      permit,\n      transferDetails,\n      msg.sender,\n      permit2.signature\n    );\n    return _swapMulti(\n      inputs,\n      outputs,\n      valueOutMin,\n      pathDefinition,\n      executor,\n      referralCode\n    );\n  }\n  function _swapMulti(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor,\n    uint32 referralCode\n  )\n    internal\n    returns (uint256[] memory amountsOut)\n  {\n    require(valueOutMin > 0, "Slippage limit too low");\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    {\n      for (uint256 i = 0; i < inputs.length; i++) {\n        amountsIn[i] = inputs[i].amountIn;\n        tokensIn[i] = inputs[i].tokenAddress;\n        for (uint256 j = 0; j < i; j++) {\n          require(\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\n            "Duplicate source tokens"\n          );\n        }\n        for (uint256 j = 0; j < outputs.length; j++) {\n          require(\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\n            "Arbitrage not supported"\n          );\n        }\n      }\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      for (uint256 j = 0; j < i; j++) {\n        require(\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\n          "Duplicate destination tokens"\n        );\n      }\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\n    }\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\n    referralInfo memory thisReferralInfo;\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n      thisReferralInfo = referralLookup[referralCode];\n    }\n    {\n      uint256 valueOut;\n      uint256 _swapMultiFee = swapMultiFee;\n      amountsOut = new uint256[](outputs.length);\n      for (uint256 i = 0; i < outputs.length; i++) {\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\n          _universalTransfer(\n            outputs[i].tokenAddress,\n            thisReferralInfo.beneficiary,\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\n          );\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\n        }\n        _universalTransfer(\n          outputs[i].tokenAddress,\n          outputs[i].receiver,\n          amountsOut[i]\n        );\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\n      }\n      require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    }\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n        tokensOut[i] = outputs[i].tokenAddress;\n    }\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      referralCode\n    );\n  }\n  function registerReferralCode(\n    uint32 _referralCode,\n    uint64 _referralFee,\n    address _beneficiary\n  )\n    external\n  {\n    require(!referralLookup[_referralCode].registered, "Code in use");\n    require(_referralFee <= FEE_DENOM / 50, "Fee too high");\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\n      require(_referralFee == 0, "Invalid fee for code");\n    } else {\n      require(_referralFee > 0, "Invalid fee for code");\n      require(_beneficiary != address(0), "Null beneficiary");\n    }\n    referralLookup[_referralCode].referralFee = _referralFee;\n    referralLookup[_referralCode].beneficiary = _beneficiary;\n    referralLookup[_referralCode].registered = true;\n  }\n  function setSwapMultiFee(\n    uint256 _swapMultiFee\n  ) \n    external\n    onlyOwner\n  {\n    require(_swapMultiFee <= FEE_DENOM / 200, "Fee too high");\n    swapMultiFee = _swapMultiFee;\n  }\n  function writeAddressList(\n    address[] calldata addresses\n  ) \n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      addressList.push(addresses[i]);\n    }\n  }\n  function transferRouterFunds(\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    address dest\n  )\n    external\n    onlyOwner\n  {\n    require(tokens.length == amounts.length, "Invalid funds transfer");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _universalTransfer(\n        tokens[i], \n        dest, \n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\n      );\n    }\n  }\n  function swapRouterFunds(\n    inputTokenInfo[] memory inputs,\n    outputTokenInfo[] memory outputs,\n    uint256 valueOutMin,\n    bytes calldata pathDefinition,\n    address executor\n  )\n    external\n    onlyOwner\n    returns (uint256[] memory amountsOut)\n  {\n    uint256[] memory amountsIn = new uint256[](inputs.length);\n    address[] memory tokensIn = new address[](inputs.length);\n    for (uint256 i = 0; i < inputs.length; i++) {\n      tokensIn[i] = inputs[i].tokenAddress;\n      amountsIn[i] = inputs[i].amountIn == 0 ? \n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\n      _universalTransfer(\n        tokensIn[i],\n        inputs[i].receiver,\n        amountsIn[i]\n      );\n    }\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\n    address[] memory tokensOut = new address[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      tokensOut[i] = outputs[i].tokenAddress;\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\n    }\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\n    uint256 valueOut;\n    amountsOut = new uint256[](outputs.length);\n    for (uint256 i = 0; i < outputs.length; i++) {\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\n      _universalTransfer(\n        outputs[i].tokenAddress,\n        outputs[i].receiver,\n        amountsOut[i]\n      );\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\n    }\n    require(valueOut >= valueOutMin, "Slippage Limit Exceeded");\n    emit SwapMulti(\n      msg.sender,\n      amountsIn,\n      tokensIn,\n      amountsOut,\n      tokensOut,\n      0\n    );\n  }\n  function _universalBalance(address token) private view returns(uint256) {\n    if (token == _ETH) {\n      return address(this).balance;\n    } else {\n      return IERC20(token).balanceOf(address(this));\n    }\n  }\n  function _universalTransfer(address token, address to, uint256 amount) private {\n    if (token == _ETH) {\n      (bool success,) = payable(to).call{value: amount}("");\n      require(success, "ETH transfer failed");\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x19ceead7105607cd444f5ad10dd51356436095a1/0x19ceead7105607cd444f5ad10dd51356436095a1.sol'}
