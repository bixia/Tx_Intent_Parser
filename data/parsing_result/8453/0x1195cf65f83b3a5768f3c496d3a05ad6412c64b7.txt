{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 22, 'end_line': 36, 'offset_start': 451, 'offset_end': 1038, 'content': 'function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 37, 'end_line': 41, 'offset_start': 1044, 'offset_end': 1298, 'content': 'function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 42, 'end_line': 48, 'offset_start': 1304, 'offset_end': 1660, 'content': 'function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 49, 'end_line': 53, 'offset_start': 1666, 'offset_end': 1915, 'content': 'function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 54, 'end_line': 68, 'offset_start': 1921, 'offset_end': 2490, 'content': 'function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 69, 'end_line': 73, 'offset_start': 2496, 'offset_end': 2755, 'content': 'function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA._throwError', 'start_line': 74, 'end_line': 84, 'offset_start': 2761, 'offset_end': 3269, 'content': 'function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._checkInitializing', 'start_line': 130, 'end_line': 134, 'offset_start': 4783, 'offset_end': 4923, 'content': 'function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 135, 'end_line': 144, 'offset_start': 4929, 'offset_end': 5293, 'content': 'function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 145, 'end_line': 147, 'offset_start': 5299, 'offset_end': 5426, 'content': 'function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 148, 'end_line': 150, 'offset_start': 5432, 'offset_end': 5551, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializableStorage', 'start_line': 151, 'end_line': 155, 'offset_start': 5557, 'offset_end': 5726, 'content': 'function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._getEIP712Storage', 'start_line': 171, 'end_line': 175, 'offset_start': 6471, 'offset_end': 6626, 'content': 'function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable.__EIP712_init', 'start_line': 176, 'end_line': 178, 'offset_start': 6632, 'offset_end': 6778, 'content': 'function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable.__EIP712_init_unchained', 'start_line': 179, 'end_line': 185, 'offset_start': 6784, 'offset_end': 7058, 'content': 'function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._domainSeparatorV4', 'start_line': 186, 'end_line': 188, 'offset_start': 7064, 'offset_end': 7172, 'content': 'function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._buildDomainSeparator', 'start_line': 189, 'end_line': 191, 'offset_start': 7178, 'offset_end': 7368, 'content': 'function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._hashTypedDataV4', 'start_line': 192, 'end_line': 194, 'offset_start': 7374, 'offset_end': 7549, 'content': 'function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable.eip712Domain', 'start_line': 195, 'end_line': 220, 'offset_start': 7555, 'offset_end': 8245, 'content': 'function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712Name', 'start_line': 221, 'end_line': 224, 'offset_start': 8251, 'offset_end': 8405, 'content': 'function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712Version', 'start_line': 225, 'end_line': 228, 'offset_start': 8411, 'offset_end': 8571, 'content': 'function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712NameHash', 'start_line': 229, 'end_line': 242, 'offset_start': 8577, 'offset_end': 9040, 'content': 'function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712VersionHash', 'start_line': 243, 'end_line': 256, 'offset_start': 9046, 'offset_end': 9536, 'content': 'function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.tor', 'start_line': 379, 'end_line': 381, 'offset_start': 14286, 'offset_end': 14338, 'content': 'constructor() {\n        _disableInitializers();\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.cubeVersion', 'start_line': 382, 'end_line': 384, 'offset_start': 14344, 'offset_end': 14431, 'content': 'function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.initialize', 'start_line': 385, 'end_line': 399, 'offset_start': 14437, 'offset_end': 14952, 'content': 'function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._authorizeUpgrade', 'start_line': 400, 'end_line': 404, 'offset_start': 14958, 'offset_end': 15083, 'content': 'function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.isQuestActive', 'start_line': 405, 'end_line': 407, 'offset_start': 15089, 'offset_end': 15196, 'content': 'function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.tokenURI', 'start_line': 408, 'end_line': 410, 'offset_start': 15202, 'offset_end': 15337, 'content': 'function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.mintCube', 'start_line': 411, 'end_line': 423, 'offset_start': 15343, 'offset_end': 15703, 'content': 'function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.mintCubes', 'start_line': 424, 'end_line': 451, 'offset_start': 15709, 'offset_end': 16522, 'content': 'function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._mintCube', 'start_line': 452, 'end_line': 501, 'offset_start': 16528, 'offset_end': 18226, 'content': 'function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._validateSignature', 'start_line': 502, 'end_line': 511, 'offset_start': 18232, 'offset_end': 18602, 'content': 'function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._processPayouts', 'start_line': 512, 'end_line': 540, 'offset_start': 18608, 'offset_end': 19750, 'content': 'function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._getSigner', 'start_line': 541, 'end_line': 548, 'offset_start': 19756, 'offset_end': 19969, 'content': 'function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._computeDigest', 'start_line': 549, 'end_line': 551, 'offset_start': 19975, 'offset_end': 20127, 'content': 'function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._getStructHash', 'start_line': 552, 'end_line': 566, 'offset_start': 20133, 'offset_end': 20666, 'content': 'function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeString', 'start_line': 567, 'end_line': 569, 'offset_start': 20672, 'offset_end': 20800, 'content': 'function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeTx', 'start_line': 570, 'end_line': 576, 'offset_start': 20806, 'offset_end': 21071, 'content': 'function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeCompletedTxs', 'start_line': 577, 'end_line': 590, 'offset_start': 21077, 'offset_end': 21511, 'content': 'function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeRecipient', 'start_line': 591, 'end_line': 593, 'offset_start': 21517, 'offset_end': 21688, 'content': 'function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeRecipients', 'start_line': 594, 'end_line': 603, 'offset_start': 21694, 'offset_end': 22115, 'content': 'function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeReward', 'start_line': 604, 'end_line': 617, 'offset_start': 22121, 'offset_end': 22539, 'content': 'function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.setIsMintingActive', 'start_line': 618, 'end_line': 621, 'offset_start': 22545, 'offset_end': 22732, 'content': 'function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.withdraw', 'start_line': 622, 'end_line': 628, 'offset_start': 22738, 'offset_end': 23012, 'content': 'function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.initializeQuest', 'start_line': 629, 'end_line': 639, 'offset_start': 23018, 'offset_end': 23387, 'content': 'function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.unpublishQuest', 'start_line': 640, 'end_line': 643, 'offset_start': 23393, 'offset_end': 23543, 'content': 'function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.supportsInterface', 'start_line': 644, 'end_line': 651, 'offset_start': 23549, 'offset_end': 23772, 'content': 'function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._getAccessControlStorage', 'start_line': 668, 'end_line': 672, 'offset_start': 24594, 'offset_end': 24770, 'content': 'function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.__AccessControl_init', 'start_line': 677, 'end_line': 678, 'offset_start': 24857, 'offset_end': 24921, 'content': 'function __AccessControl_init() internal onlyInitializing {\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.__AccessControl_init_unchained', 'start_line': 679, 'end_line': 680, 'offset_start': 24927, 'offset_end': 25001, 'content': 'function __AccessControl_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.supportsInterface', 'start_line': 681, 'end_line': 683, 'offset_start': 25007, 'offset_end': 25208, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.hasRole', 'start_line': 684, 'end_line': 687, 'offset_start': 25214, 'offset_end': 25420, 'content': 'function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._checkRole', 'start_line': 688, 'end_line': 690, 'offset_start': 25426, 'offset_end': 25528, 'content': 'function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._checkRole', 'start_line': 691, 'end_line': 695, 'offset_start': 25534, 'offset_end': 25730, 'content': 'function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.getRoleAdmin', 'start_line': 696, 'end_line': 699, 'offset_start': 25736, 'offset_end': 25926, 'content': 'function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.grantRole', 'start_line': 700, 'end_line': 702, 'offset_start': 25932, 'offset_end': 26067, 'content': 'function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.revokeRole', 'start_line': 703, 'end_line': 705, 'offset_start': 26073, 'offset_end': 26210, 'content': 'function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.renounceRole', 'start_line': 706, 'end_line': 711, 'offset_start': 26216, 'offset_end': 26459, 'content': 'function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._setRoleAdmin', 'start_line': 712, 'end_line': 717, 'offset_start': 26465, 'offset_end': 26782, 'content': 'function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._grantRole', 'start_line': 718, 'end_line': 727, 'offset_start': 26788, 'offset_end': 27174, 'content': 'function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._revokeRole', 'start_line': 728, 'end_line': 737, 'offset_start': 27180, 'offset_end': 27567, 'content': 'function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init', 'start_line': 756, 'end_line': 757, 'offset_start': 28254, 'offset_end': 28320, 'content': 'function __UUPSUpgradeable_init() internal onlyInitializing {\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init_unchained', 'start_line': 758, 'end_line': 759, 'offset_start': 28326, 'offset_end': 28402, 'content': 'function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.proxiableUUID', 'start_line': 760, 'end_line': 762, 'offset_start': 28408, 'offset_end': 28541, 'content': 'function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.upgradeToAndCall', 'start_line': 763, 'end_line': 766, 'offset_start': 28547, 'offset_end': 28760, 'content': 'function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._checkProxy', 'start_line': 767, 'end_line': 774, 'offset_start': 28766, 'offset_end': 28998, 'content': 'function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._checkNotDelegated', 'start_line': 775, 'end_line': 779, 'offset_start': 29004, 'offset_end': 29161, 'content': 'function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._authorizeUpgrade', 'start_line': 780, 'end_line': 780, 'offset_start': 29167, 'offset_end': 29237, 'content': 'function _authorizeUpgrade(address newImplementation) internal virtual;', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._upgradeToAndCallUUPS', 'start_line': 781, 'end_line': 790, 'offset_start': 29243, 'offset_end': 29734, 'content': 'function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.balanceOf', 'start_line': 798, 'end_line': 798, 'offset_start': 30132, 'offset_end': 30205, 'content': 'function balanceOf(address owner) external view returns (uint256 balance);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.ownerOf', 'start_line': 799, 'end_line': 799, 'offset_start': 30211, 'offset_end': 30282, 'content': 'function ownerOf(uint256 tokenId) external view returns (address owner);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.safeTransferFrom', 'start_line': 800, 'end_line': 800, 'offset_start': 30288, 'offset_end': 30386, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.safeTransferFrom', 'start_line': 801, 'end_line': 801, 'offset_start': 30392, 'offset_end': 30469, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.transferFrom', 'start_line': 802, 'end_line': 802, 'offset_start': 30475, 'offset_end': 30548, 'content': 'function transferFrom(address from, address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.approve', 'start_line': 803, 'end_line': 803, 'offset_start': 30554, 'offset_end': 30608, 'content': 'function approve(address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.setApprovalForAll', 'start_line': 804, 'end_line': 804, 'offset_start': 30614, 'offset_end': 30682, 'content': 'function setApprovalForAll(address operator, bool approved) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.getApproved', 'start_line': 805, 'end_line': 805, 'offset_start': 30688, 'offset_end': 30766, 'content': 'function getApproved(uint256 tokenId) external view returns (address operator);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.isApprovedForAll', 'start_line': 806, 'end_line': 806, 'offset_start': 30772, 'offset_end': 30859, 'content': 'function isApprovedForAll(address owner, address operator) external view returns (bool);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getImplementation', 'start_line': 821, 'end_line': 823, 'offset_start': 31544, 'offset_end': 31681, 'content': 'function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setImplementation', 'start_line': 824, 'end_line': 829, 'offset_start': 31687, 'offset_end': 31967, 'content': 'function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.upgradeToAndCall', 'start_line': 830, 'end_line': 838, 'offset_start': 31973, 'offset_end': 32306, 'content': 'function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getAdmin', 'start_line': 840, 'end_line': 842, 'offset_start': 32423, 'offset_end': 32542, 'content': 'function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setAdmin', 'start_line': 843, 'end_line': 848, 'offset_start': 32548, 'offset_end': 32764, 'content': 'function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.changeAdmin', 'start_line': 849, 'end_line': 852, 'offset_start': 32770, 'offset_end': 32902, 'content': 'function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getBeacon', 'start_line': 854, 'end_line': 856, 'offset_start': 33020, 'offset_end': 33141, 'content': 'function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setBeacon', 'start_line': 857, 'end_line': 866, 'offset_start': 33147, 'offset_end': 33581, 'content': 'function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.upgradeBeaconToAndCall', 'start_line': 867, 'end_line': 875, 'offset_start': 33587, 'offset_end': 33918, 'content': 'function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._checkNonPayable', 'start_line': 876, 'end_line': 880, 'offset_start': 33924, 'offset_end': 34045, 'content': 'function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.name', 'start_line': 885, 'end_line': 885, 'offset_start': 34157, 'offset_end': 34210, 'content': 'function name() external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.symbol', 'start_line': 886, 'end_line': 886, 'offset_start': 34216, 'offset_end': 34271, 'content': 'function symbol() external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.tokenURI', 'start_line': 887, 'end_line': 887, 'offset_start': 34277, 'offset_end': 34349, 'content': 'function tokenURI(uint256 tokenId) external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC5267.eip712Domain', 'start_line': 892, 'end_line': 903, 'offset_start': 34436, 'offset_end': 34745, 'content': 'function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );', 'contract_name': 'IERC5267', 'contract_code': '{\n    event EIP712DomainChanged();\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryAdd', 'start_line': 914, 'end_line': 920, 'offset_start': 34916, 'offset_end': 35131, 'content': 'function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.trySub', 'start_line': 921, 'end_line': 926, 'offset_start': 35137, 'offset_end': 35325, 'content': 'function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryMul', 'start_line': 927, 'end_line': 934, 'offset_start': 35331, 'offset_end': 35593, 'content': 'function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryDiv', 'start_line': 935, 'end_line': 940, 'offset_start': 35599, 'offset_end': 35788, 'content': 'function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryMod', 'start_line': 941, 'end_line': 946, 'offset_start': 35794, 'offset_end': 35983, 'content': 'function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.max', 'start_line': 947, 'end_line': 949, 'offset_start': 35989, 'offset_end': 36092, 'content': 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.min', 'start_line': 950, 'end_line': 952, 'offset_start': 36098, 'offset_end': 36201, 'content': 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.average', 'start_line': 953, 'end_line': 955, 'offset_start': 36207, 'offset_end': 36322, 'content': 'function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.ceilDiv', 'start_line': 956, 'end_line': 961, 'offset_start': 36328, 'offset_end': 36508, 'content': 'function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 962, 'end_line': 999, 'offset_start': 36514, 'offset_end': 37981, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 1000, 'end_line': 1006, 'offset_start': 37987, 'offset_end': 38288, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 1007, 'end_line': 1022, 'offset_start': 38294, 'offset_end': 38874, 'content': 'function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 1023, 'end_line': 1028, 'offset_start': 38880, 'offset_end': 39119, 'content': 'function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 1029, 'end_line': 1065, 'offset_start': 39125, 'offset_end': 40107, 'content': 'function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 1066, 'end_line': 1071, 'offset_start': 40113, 'offset_end': 40360, 'content': 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 1072, 'end_line': 1104, 'offset_start': 40366, 'offset_end': 41281, 'content': 'function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 1105, 'end_line': 1110, 'offset_start': 41287, 'offset_end': 41537, 'content': 'function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 1111, 'end_line': 1135, 'offset_start': 41543, 'offset_end': 42205, 'content': 'function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 1136, 'end_line': 1141, 'offset_start': 42211, 'offset_end': 42469, 'content': 'function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.unsignedRoundsUp', 'start_line': 1142, 'end_line': 1144, 'offset_start': 42475, 'offset_end': 42596, 'content': 'function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.max', 'start_line': 1148, 'end_line': 1150, 'offset_start': 42650, 'offset_end': 42750, 'content': 'function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.min', 'start_line': 1151, 'end_line': 1153, 'offset_start': 42756, 'offset_end': 42856, 'content': 'function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.average', 'start_line': 1154, 'end_line': 1157, 'offset_start': 42862, 'offset_end': 43039, 'content': 'function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.abs', 'start_line': 1158, 'end_line': 1162, 'offset_start': 43045, 'offset_end': 43181, 'content': 'function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IBeacon.implementation', 'start_line': 1166, 'end_line': 1166, 'offset_start': 43234, 'offset_end': 43291, 'content': 'function implementation() external view returns (address);', 'contract_name': 'IBeacon', 'contract_code': '{\n    function implementation() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._getReentrancyGuardStorage', 'start_line': 1177, 'end_line': 1181, 'offset_start': 43737, 'offset_end': 43919, 'content': 'function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init', 'start_line': 1183, 'end_line': 1185, 'offset_start': 43967, 'offset_end': 44077, 'content': 'function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained', 'start_line': 1186, 'end_line': 1189, 'offset_start': 44083, 'offset_end': 44265, 'content': 'function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantBefore', 'start_line': 1195, 'end_line': 1201, 'offset_start': 44379, 'offset_end': 44623, 'content': 'function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantAfter', 'start_line': 1202, 'end_line': 1205, 'offset_start': 44629, 'offset_end': 44779, 'content': 'function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._reentrancyGuardEntered', 'start_line': 1206, 'end_line': 1209, 'offset_start': 44785, 'offset_end': 44965, 'content': 'function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC165.supportsInterface', 'start_line': 1213, 'end_line': 1213, 'offset_start': 45018, 'offset_end': 45093, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165', 'contract_code': '{\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.sendValue', 'start_line': 1220, 'end_line': 1228, 'offset_start': 45272, 'offset_end': 45601, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 1229, 'end_line': 1231, 'offset_start': 45607, 'offset_end': 45757, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 1232, 'end_line': 1238, 'offset_start': 45763, 'offset_end': 46154, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 1239, 'end_line': 1242, 'offset_start': 46160, 'offset_end': 46413, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 1243, 'end_line': 1246, 'offset_start': 46419, 'offset_end': 46671, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResultFromTarget', 'start_line': 1247, 'end_line': 1260, 'offset_start': 46677, 'offset_end': 47088, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResult', 'start_line': 1261, 'end_line': 1267, 'offset_start': 47094, 'offset_end': 47317, 'content': 'function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address._revert', 'start_line': 1268, 'end_line': 1277, 'offset_start': 47323, 'offset_end': 47641, 'content': 'function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.distributeRewards', 'start_line': 1283, 'end_line': 1291, 'offset_start': 47790, 'offset_end': 48008, 'content': 'function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.withdrawFunds', 'start_line': 1292, 'end_line': 1298, 'offset_start': 48014, 'offset_end': 48173, 'content': 'function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.createEscrow', 'start_line': 1299, 'end_line': 1304, 'offset_start': 48179, 'offset_end': 48333, 'content': 'function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.updateEscrowAdmin', 'start_line': 1305, 'end_line': 1305, 'offset_start': 48339, 'offset_end': 48409, 'content': 'function updateEscrowAdmin(uint256 questId, address newAdmin) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.addTokenToWhitelist', 'start_line': 1306, 'end_line': 1306, 'offset_start': 48415, 'offset_end': 48484, 'content': 'function addTokenToWhitelist(uint256 questId, address token) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.removeTokenFromWhitelist', 'start_line': 1307, 'end_line': 1307, 'offset_start': 48490, 'offset_end': 48564, 'content': 'function removeTokenFromWhitelist(uint256 questId, address token) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.initialize', 'start_line': 1308, 'end_line': 1308, 'offset_start': 48570, 'offset_end': 48613, 'content': 'function initialize(address admin) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.hasRole', 'start_line': 1317, 'end_line': 1317, 'offset_start': 49099, 'offset_end': 49175, 'content': 'function hasRole(bytes32 role, address account) external view returns (bool);', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.getRoleAdmin', 'start_line': 1318, 'end_line': 1318, 'offset_start': 49181, 'offset_end': 49248, 'content': 'function getRoleAdmin(bytes32 role) external view returns (bytes32);', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.grantRole', 'start_line': 1319, 'end_line': 1319, 'offset_start': 49254, 'offset_end': 49312, 'content': 'function grantRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.revokeRole', 'start_line': 1320, 'end_line': 1320, 'offset_start': 49318, 'offset_end': 49377, 'content': 'function revokeRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.renounceRole', 'start_line': 1321, 'end_line': 1321, 'offset_start': 49383, 'offset_end': 49455, 'content': 'function renounceRole(bytes32 role, address callerConfirmation) external;', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 1326, 'end_line': 1327, 'offset_start': 49608, 'offset_end': 49666, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 1328, 'end_line': 1329, 'offset_start': 49672, 'offset_end': 49740, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 1330, 'end_line': 1332, 'offset_start': 49746, 'offset_end': 49841, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 1333, 'end_line': 1335, 'offset_start': 49847, 'offset_end': 49945, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._getERC721Storage', 'start_line': 1358, 'end_line': 1362, 'offset_start': 51318, 'offset_end': 51473, 'content': 'function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.__ERC721_init', 'start_line': 1363, 'end_line': 1365, 'offset_start': 51479, 'offset_end': 51627, 'content': 'function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.__ERC721_init_unchained', 'start_line': 1366, 'end_line': 1370, 'offset_start': 51633, 'offset_end': 51851, 'content': 'function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.supportsInterface', 'start_line': 1371, 'end_line': 1376, 'offset_start': 51857, 'offset_end': 52167, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.balanceOf', 'start_line': 1377, 'end_line': 1383, 'offset_start': 52173, 'offset_end': 52437, 'content': 'function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.ownerOf', 'start_line': 1384, 'end_line': 1386, 'offset_start': 52443, 'offset_end': 52560, 'content': 'function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.name', 'start_line': 1387, 'end_line': 1390, 'offset_start': 52566, 'offset_end': 52711, 'content': 'function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.symbol', 'start_line': 1391, 'end_line': 1394, 'offset_start': 52717, 'offset_end': 52866, 'content': 'function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.tokenURI', 'start_line': 1395, 'end_line': 1399, 'offset_start': 52872, 'offset_end': 53125, 'content': 'function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._baseURI', 'start_line': 1400, 'end_line': 1402, 'offset_start': 53131, 'offset_end': 53222, 'content': 'function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.approve', 'start_line': 1403, 'end_line': 1405, 'offset_start': 53228, 'offset_end': 53340, 'content': 'function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.getApproved', 'start_line': 1406, 'end_line': 1409, 'offset_start': 53346, 'offset_end': 53498, 'content': 'function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.setApprovalForAll', 'start_line': 1410, 'end_line': 1412, 'offset_start': 53504, 'offset_end': 53647, 'content': 'function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.isApprovedForAll', 'start_line': 1413, 'end_line': 1416, 'offset_start': 53653, 'offset_end': 53862, 'content': 'function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.transferFrom', 'start_line': 1417, 'end_line': 1425, 'offset_start': 53868, 'offset_end': 54236, 'content': 'function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.safeTransferFrom', 'start_line': 1426, 'end_line': 1428, 'offset_start': 54242, 'offset_end': 54373, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.safeTransferFrom', 'start_line': 1429, 'end_line': 1432, 'offset_start': 54379, 'offset_end': 54586, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._ownerOf', 'start_line': 1433, 'end_line': 1436, 'offset_start': 54592, 'offset_end': 54763, 'content': 'function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._getApproved', 'start_line': 1437, 'end_line': 1440, 'offset_start': 54769, 'offset_end': 54952, 'content': 'function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._isAuthorized', 'start_line': 1441, 'end_line': 1445, 'offset_start': 54958, 'offset_end': 55229, 'content': 'function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._checkAuthorized', 'start_line': 1446, 'end_line': 1454, 'offset_start': 55235, 'offset_end': 55602, 'content': 'function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._increaseBalance', 'start_line': 1455, 'end_line': 1460, 'offset_start': 55608, 'offset_end': 55817, 'content': 'function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._update', 'start_line': 1461, 'end_line': 1481, 'offset_start': 55823, 'offset_end': 56514, 'content': 'function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._mint', 'start_line': 1482, 'end_line': 1490, 'offset_start': 56520, 'offset_end': 56846, 'content': 'function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeMint', 'start_line': 1491, 'end_line': 1493, 'offset_start': 56852, 'offset_end': 56951, 'content': 'function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeMint', 'start_line': 1494, 'end_line': 1497, 'offset_start': 56957, 'offset_end': 57138, 'content': 'function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._burn', 'start_line': 1498, 'end_line': 1503, 'offset_start': 57144, 'offset_end': 57370, 'content': 'function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._transfer', 'start_line': 1504, 'end_line': 1514, 'offset_start': 57376, 'offset_end': 57835, 'content': 'function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeTransfer', 'start_line': 1515, 'end_line': 1517, 'offset_start': 57841, 'offset_end': 57968, 'content': 'function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeTransfer', 'start_line': 1518, 'end_line': 1521, 'offset_start': 57974, 'offset_end': 58177, 'content': 'function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._approve', 'start_line': 1522, 'end_line': 1524, 'offset_start': 58183, 'offset_end': 58302, 'content': 'function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._approve', 'start_line': 1525, 'end_line': 1537, 'offset_start': 58308, 'offset_end': 58862, 'content': 'function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._setApprovalForAll', 'start_line': 1538, 'end_line': 1545, 'offset_start': 58868, 'offset_end': 59236, 'content': 'function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._requireOwned', 'start_line': 1546, 'end_line': 1552, 'offset_start': 59242, 'offset_end': 59482, 'content': 'function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._checkOnERC721Received', 'start_line': 1553, 'end_line': 1569, 'offset_start': 59488, 'offset_end': 60214, 'content': 'function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init', 'start_line': 1603, 'end_line': 1604, 'offset_start': 61845, 'offset_end': 61902, 'content': 'function __ERC165_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init_unchained', 'start_line': 1605, 'end_line': 1606, 'offset_start': 61908, 'offset_end': 61975, 'content': 'function __ERC165_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.supportsInterface', 'start_line': 1607, 'end_line': 1609, 'offset_start': 61981, 'offset_end': 62126, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1822Proxiable.proxiableUUID', 'start_line': 1613, 'end_line': 1613, 'offset_start': 62189, 'offset_end': 62245, 'content': 'function proxiableUUID() external view returns (bytes32);', 'contract_name': 'IERC1822Proxiable', 'contract_code': '{\n    function proxiableUUID() external view returns (bytes32);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toEthSignedMessageHash', 'start_line': 1618, 'end_line': 1624, 'offset_start': 62345, 'offset_end': 62618, 'content': 'function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toEthSignedMessageHash', 'start_line': 1625, 'end_line': 1628, 'offset_start': 62624, 'offset_end': 62852, 'content': 'function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toDataWithIntendedValidatorHash', 'start_line': 1629, 'end_line': 1631, 'offset_start': 62858, 'offset_end': 63048, 'content': 'function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toTypedDataHash', 'start_line': 1632, 'end_line': 1640, 'offset_start': 63054, 'offset_end': 63411, 'content': 'function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toString', 'start_line': 1649, 'end_line': 1667, 'offset_start': 63731, 'offset_end': 64330, 'content': 'function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toStringSigned', 'start_line': 1668, 'end_line': 1670, 'offset_start': 64336, 'offset_end': 64503, 'content': 'function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 1671, 'end_line': 1675, 'offset_start': 64509, 'offset_end': 64682, 'content': 'function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 1676, 'end_line': 1689, 'offset_start': 64688, 'offset_end': 65212, 'content': 'function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 1690, 'end_line': 1692, 'offset_start': 65218, 'offset_end': 65365, 'content': 'function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.equal', 'start_line': 1693, 'end_line': 1695, 'offset_start': 65371, 'offset_end': 65552, 'content': 'function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Receiver.onERC721Received', 'start_line': 1699, 'end_line': 1704, 'offset_start': 65613, 'offset_end': 65772, 'content': 'function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);', 'contract_name': 'IERC721Receiver', 'contract_code': '{\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getAddressSlot', 'start_line': 1726, 'end_line': 1730, 'offset_start': 66142, 'offset_end': 66288, 'content': 'function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBooleanSlot', 'start_line': 1731, 'end_line': 1735, 'offset_start': 66294, 'offset_end': 66440, 'content': 'function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytes32Slot', 'start_line': 1736, 'end_line': 1740, 'offset_start': 66446, 'offset_end': 66592, 'content': 'function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getUint256Slot', 'start_line': 1741, 'end_line': 1745, 'offset_start': 66598, 'offset_end': 66744, 'content': 'function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getStringSlot', 'start_line': 1746, 'end_line': 1750, 'offset_start': 66750, 'offset_end': 66894, 'content': 'function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getStringSlot', 'start_line': 1751, 'end_line': 1755, 'offset_start': 66900, 'offset_end': 67058, 'content': 'function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytesSlot', 'start_line': 1756, 'end_line': 1760, 'offset_start': 67064, 'offset_end': 67206, 'content': 'function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytesSlot', 'start_line': 1761, 'end_line': 1765, 'offset_start': 67212, 'offset_end': 67367, 'content': 'function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
